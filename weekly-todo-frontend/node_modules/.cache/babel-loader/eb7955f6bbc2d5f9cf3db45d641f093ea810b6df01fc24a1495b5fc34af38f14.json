{"ast":null,"code":"import { getComputedStyle } from '@zag-js/dom-query';\n\n// src/index.ts\nfunction getScrollPadding(element) {\n  const style = getComputedStyle(element);\n  const rect = element.getBoundingClientRect();\n  let xBeforeRaw = style.getPropertyValue(\"scroll-padding-left\").replace(\"auto\", \"0px\");\n  let yBeforeRaw = style.getPropertyValue(\"scroll-padding-top\").replace(\"auto\", \"0px\");\n  let xAfterRaw = style.getPropertyValue(\"scroll-padding-right\").replace(\"auto\", \"0px\");\n  let yAfterRaw = style.getPropertyValue(\"scroll-padding-bottom\").replace(\"auto\", \"0px\");\n  function convert(raw, size) {\n    let n = parseFloat(raw);\n    if (/%/.test(raw)) {\n      n /= 100;\n      n *= size;\n    }\n    return Number.isNaN(n) ? 0 : n;\n  }\n  let xBefore = convert(xBeforeRaw, rect.width);\n  let yBefore = convert(yBeforeRaw, rect.height);\n  let xAfter = convert(xAfterRaw, rect.width);\n  let yAfter = convert(yAfterRaw, rect.height);\n  return {\n    x: {\n      before: xBefore,\n      after: xAfter\n    },\n    y: {\n      before: yBefore,\n      after: yAfter\n    }\n  };\n}\nfunction isRectIntersecting(a, b, axis = \"both\") {\n  return axis === \"x\" && a.right >= b.left && a.left <= b.right || axis === \"y\" && a.bottom >= b.top && a.top <= b.bottom || axis === \"both\" && a.right >= b.left && a.left <= b.right && a.bottom >= b.top && a.top <= b.bottom;\n}\nfunction getDescendants(parent) {\n  let children = [];\n  for (const child of parent.children) {\n    children = children.concat(child, getDescendants(child));\n  }\n  return children;\n}\nfunction getSnapPositions(parent, subtree = false) {\n  const parentRect = parent.getBoundingClientRect();\n  const positions = {\n    x: {\n      start: [],\n      center: [],\n      end: []\n    },\n    y: {\n      start: [],\n      center: [],\n      end: []\n    }\n  };\n  const children = subtree ? getDescendants(parent) : parent.children;\n  for (const axis of [\"x\", \"y\"]) {\n    const orthogonalAxis = axis === \"x\" ? \"y\" : \"x\";\n    const axisStart = axis === \"x\" ? \"left\" : \"top\";\n    const axisSize = axis === \"x\" ? \"width\" : \"height\";\n    const axisScroll = axis === \"x\" ? \"scrollLeft\" : \"scrollTop\";\n    for (const child of children) {\n      const childRect = child.getBoundingClientRect();\n      if (!isRectIntersecting(parentRect, childRect, orthogonalAxis)) {\n        continue;\n      }\n      const childStyle = getComputedStyle(child);\n      let [childAlignY, childAlignX] = childStyle.getPropertyValue(\"scroll-snap-align\").split(\" \");\n      if (typeof childAlignX === \"undefined\") {\n        childAlignX = childAlignY;\n      }\n      const childAlign = axis === \"x\" ? childAlignX : childAlignY;\n      const childOffsetStart = childRect[axisStart] - parentRect[axisStart] + parent[axisScroll];\n      switch (childAlign) {\n        case \"none\":\n          break;\n        case \"start\":\n          positions[axis].start.push({\n            node: child,\n            position: childOffsetStart\n          });\n          break;\n        case \"center\":\n          positions[axis].center.push({\n            node: child,\n            position: childOffsetStart + childRect[axisSize] / 2\n          });\n          break;\n        case \"end\":\n          positions[axis].end.push({\n            node: child,\n            position: childOffsetStart + childRect[axisSize]\n          });\n          break;\n      }\n    }\n  }\n  return positions;\n}\nfunction getScrollSnapPositions(element) {\n  const rect = element.getBoundingClientRect();\n  const scrollPadding = getScrollPadding(element);\n  const snapPositions = getSnapPositions(element);\n  const maxScroll = {\n    x: element.scrollWidth - element.offsetWidth,\n    y: element.scrollHeight - element.offsetHeight\n  };\n  return {\n    x: uniq([...snapPositions.x.start.map(v => v.position - scrollPadding.x.before), ...snapPositions.x.center.map(v => v.position - rect.width / 2), ...snapPositions.x.end.map(v => v.position - rect.width + scrollPadding.x.after)].map(clamp(0, maxScroll.x))),\n    y: uniq([...snapPositions.y.start.map(v => v.position - scrollPadding.y.before), ...snapPositions.y.center.map(v => v.position - rect.height / 2), ...snapPositions.y.end.map(v => v.position - rect.height + scrollPadding.y.after)].map(clamp(0, maxScroll.y)))\n  };\n}\nfunction findSnapPoint(parent, axis, predicate) {\n  const snapPositions = getSnapPositions(parent);\n  const items = [...snapPositions[axis].start, ...snapPositions[axis].center, ...snapPositions[axis].end];\n  for (const item of items) {\n    if (predicate(item.node)) {\n      return item.position;\n    }\n  }\n}\nfunction getSnapPointTarget(parent, snapPoint) {\n  const rect = parent.getBoundingClientRect();\n  const scrollPadding = getScrollPadding(parent);\n  const children = Array.from(parent.children);\n  for (const child of children) {\n    const childRect = child.getBoundingClientRect();\n    const childOffsetStart = {\n      x: childRect.left - rect.left + parent.scrollLeft,\n      y: childRect.top - rect.top + parent.scrollTop\n    };\n    const matchesX = [childOffsetStart.x - scrollPadding.x.before,\n    // start\n    childOffsetStart.x + childRect.width / 2 - rect.width / 2,\n    // center\n    childOffsetStart.x + childRect.width - rect.width + scrollPadding.x.after\n    // end\n    ].some(pos => Math.abs(pos - snapPoint) < 1);\n    const matchesY = [childOffsetStart.y - scrollPadding.y.before, childOffsetStart.y + childRect.height / 2 - rect.height / 2, childOffsetStart.y + childRect.height - rect.height + scrollPadding.y.after].some(pos => Math.abs(pos - snapPoint) < 1);\n    if (matchesX || matchesY) {\n      return child;\n    }\n  }\n  return children[0];\n}\nvar uniq = arr => [...new Set(arr)];\nvar clamp = (min, max) => value => Math.max(min, Math.min(max, value));\nexport { findSnapPoint, getScrollSnapPositions, getSnapPointTarget, getSnapPositions };","map":{"version":3,"names":["getComputedStyle","getScrollPadding","element","style","rect","getBoundingClientRect","xBeforeRaw","getPropertyValue","replace","yBeforeRaw","xAfterRaw","yAfterRaw","convert","raw","size","n","parseFloat","test","Number","isNaN","xBefore","width","yBefore","height","xAfter","yAfter","x","before","after","y","isRectIntersecting","a","b","axis","right","left","bottom","top","getDescendants","parent","children","child","concat","getSnapPositions","subtree","parentRect","positions","start","center","end","orthogonalAxis","axisStart","axisSize","axisScroll","childRect","childStyle","childAlignY","childAlignX","split","childAlign","childOffsetStart","push","node","position","getScrollSnapPositions","scrollPadding","snapPositions","maxScroll","scrollWidth","offsetWidth","scrollHeight","offsetHeight","uniq","map","v","clamp","findSnapPoint","predicate","items","item","getSnapPointTarget","snapPoint","Array","from","scrollLeft","scrollTop","matchesX","some","pos","Math","abs","matchesY","arr","Set","min","max","value"],"sources":["C:/Users/tuanl/weekly-todo-frontend/node_modules/@zag-js/scroll-snap/dist/index.mjs"],"sourcesContent":["import { getComputedStyle } from '@zag-js/dom-query';\n\n// src/index.ts\nfunction getScrollPadding(element) {\n  const style = getComputedStyle(element);\n  const rect = element.getBoundingClientRect();\n  let xBeforeRaw = style.getPropertyValue(\"scroll-padding-left\").replace(\"auto\", \"0px\");\n  let yBeforeRaw = style.getPropertyValue(\"scroll-padding-top\").replace(\"auto\", \"0px\");\n  let xAfterRaw = style.getPropertyValue(\"scroll-padding-right\").replace(\"auto\", \"0px\");\n  let yAfterRaw = style.getPropertyValue(\"scroll-padding-bottom\").replace(\"auto\", \"0px\");\n  function convert(raw, size) {\n    let n = parseFloat(raw);\n    if (/%/.test(raw)) {\n      n /= 100;\n      n *= size;\n    }\n    return Number.isNaN(n) ? 0 : n;\n  }\n  let xBefore = convert(xBeforeRaw, rect.width);\n  let yBefore = convert(yBeforeRaw, rect.height);\n  let xAfter = convert(xAfterRaw, rect.width);\n  let yAfter = convert(yAfterRaw, rect.height);\n  return {\n    x: { before: xBefore, after: xAfter },\n    y: { before: yBefore, after: yAfter }\n  };\n}\nfunction isRectIntersecting(a, b, axis = \"both\") {\n  return axis === \"x\" && a.right >= b.left && a.left <= b.right || axis === \"y\" && a.bottom >= b.top && a.top <= b.bottom || axis === \"both\" && a.right >= b.left && a.left <= b.right && a.bottom >= b.top && a.top <= b.bottom;\n}\nfunction getDescendants(parent) {\n  let children = [];\n  for (const child of parent.children) {\n    children = children.concat(child, getDescendants(child));\n  }\n  return children;\n}\nfunction getSnapPositions(parent, subtree = false) {\n  const parentRect = parent.getBoundingClientRect();\n  const positions = {\n    x: { start: [], center: [], end: [] },\n    y: { start: [], center: [], end: [] }\n  };\n  const children = subtree ? getDescendants(parent) : parent.children;\n  for (const axis of [\"x\", \"y\"]) {\n    const orthogonalAxis = axis === \"x\" ? \"y\" : \"x\";\n    const axisStart = axis === \"x\" ? \"left\" : \"top\";\n    const axisSize = axis === \"x\" ? \"width\" : \"height\";\n    const axisScroll = axis === \"x\" ? \"scrollLeft\" : \"scrollTop\";\n    for (const child of children) {\n      const childRect = child.getBoundingClientRect();\n      if (!isRectIntersecting(parentRect, childRect, orthogonalAxis)) {\n        continue;\n      }\n      const childStyle = getComputedStyle(child);\n      let [childAlignY, childAlignX] = childStyle.getPropertyValue(\"scroll-snap-align\").split(\" \");\n      if (typeof childAlignX === \"undefined\") {\n        childAlignX = childAlignY;\n      }\n      const childAlign = axis === \"x\" ? childAlignX : childAlignY;\n      const childOffsetStart = childRect[axisStart] - parentRect[axisStart] + parent[axisScroll];\n      switch (childAlign) {\n        case \"none\":\n          break;\n        case \"start\":\n          positions[axis].start.push({ node: child, position: childOffsetStart });\n          break;\n        case \"center\":\n          positions[axis].center.push({ node: child, position: childOffsetStart + childRect[axisSize] / 2 });\n          break;\n        case \"end\":\n          positions[axis].end.push({ node: child, position: childOffsetStart + childRect[axisSize] });\n          break;\n      }\n    }\n  }\n  return positions;\n}\nfunction getScrollSnapPositions(element) {\n  const rect = element.getBoundingClientRect();\n  const scrollPadding = getScrollPadding(element);\n  const snapPositions = getSnapPositions(element);\n  const maxScroll = {\n    x: element.scrollWidth - element.offsetWidth,\n    y: element.scrollHeight - element.offsetHeight\n  };\n  return {\n    x: uniq(\n      [\n        ...snapPositions.x.start.map((v) => v.position - scrollPadding.x.before),\n        ...snapPositions.x.center.map((v) => v.position - rect.width / 2),\n        ...snapPositions.x.end.map((v) => v.position - rect.width + scrollPadding.x.after)\n      ].map(clamp(0, maxScroll.x))\n    ),\n    y: uniq(\n      [\n        ...snapPositions.y.start.map((v) => v.position - scrollPadding.y.before),\n        ...snapPositions.y.center.map((v) => v.position - rect.height / 2),\n        ...snapPositions.y.end.map((v) => v.position - rect.height + scrollPadding.y.after)\n      ].map(clamp(0, maxScroll.y))\n    )\n  };\n}\nfunction findSnapPoint(parent, axis, predicate) {\n  const snapPositions = getSnapPositions(parent);\n  const items = [...snapPositions[axis].start, ...snapPositions[axis].center, ...snapPositions[axis].end];\n  for (const item of items) {\n    if (predicate(item.node)) {\n      return item.position;\n    }\n  }\n}\nfunction getSnapPointTarget(parent, snapPoint) {\n  const rect = parent.getBoundingClientRect();\n  const scrollPadding = getScrollPadding(parent);\n  const children = Array.from(parent.children);\n  for (const child of children) {\n    const childRect = child.getBoundingClientRect();\n    const childOffsetStart = {\n      x: childRect.left - rect.left + parent.scrollLeft,\n      y: childRect.top - rect.top + parent.scrollTop\n    };\n    const matchesX = [\n      childOffsetStart.x - scrollPadding.x.before,\n      // start\n      childOffsetStart.x + childRect.width / 2 - rect.width / 2,\n      // center\n      childOffsetStart.x + childRect.width - rect.width + scrollPadding.x.after\n      // end\n    ].some((pos) => Math.abs(pos - snapPoint) < 1);\n    const matchesY = [\n      childOffsetStart.y - scrollPadding.y.before,\n      childOffsetStart.y + childRect.height / 2 - rect.height / 2,\n      childOffsetStart.y + childRect.height - rect.height + scrollPadding.y.after\n    ].some((pos) => Math.abs(pos - snapPoint) < 1);\n    if (matchesX || matchesY) {\n      return child;\n    }\n  }\n  return children[0];\n}\nvar uniq = (arr) => [...new Set(arr)];\nvar clamp = (min, max) => (value) => Math.max(min, Math.min(max, value));\n\nexport { findSnapPoint, getScrollSnapPositions, getSnapPointTarget, getSnapPositions };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}