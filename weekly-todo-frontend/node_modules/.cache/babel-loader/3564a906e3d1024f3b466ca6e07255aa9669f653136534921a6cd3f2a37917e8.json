{"ast":null,"code":"import { compact, isEqual, chunk, prevIndex, nextIndex, isObject, hasProp } from '@zag-js/utils';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar fallback = {\n  itemToValue(item) {\n    if (typeof item === \"string\") return item;\n    if (isObject(item) && hasProp(item, \"value\")) return item.value;\n    return \"\";\n  },\n  itemToString(item) {\n    if (typeof item === \"string\") return item;\n    if (isObject(item) && hasProp(item, \"label\")) return item.label;\n    return fallback.itemToValue(item);\n  },\n  isItemDisabled(item) {\n    if (isObject(item) && hasProp(item, \"disabled\")) return !!item.disabled;\n    return false;\n  }\n};\nvar ListCollection = class _ListCollection {\n  constructor(options) {\n    this.options = options;\n    /**\n     * The items in the collection\n     */\n    __publicField(this, \"items\");\n    /**\n     * Copy the collection\n     */\n    __publicField(this, \"copy\", items => {\n      return new _ListCollection({\n        ...this.options,\n        items: items ?? [...this.items]\n      });\n    });\n    /**\n     * Check if the collection is equal to another collection\n     */\n    __publicField(this, \"isEqual\", other => {\n      return isEqual(this.items, other.items);\n    });\n    /**\n     * Function to update the collection items\n     */\n    __publicField(this, \"setItems\", items => {\n      return this.copy(items);\n    });\n    /**\n     * Returns all the values in the collection\n     */\n    __publicField(this, \"getValues\", (items = this.items) => {\n      return Array.from(items).map(item => this.getItemValue(item)).filter(Boolean);\n    });\n    /**\n     * Get the item based on its value\n     */\n    __publicField(this, \"find\", value => {\n      if (value == null) return null;\n      const index = this.indexOf(value);\n      return index != null ? this.at(index) : null;\n    });\n    /**\n     * Get the items based on its values\n     */\n    __publicField(this, \"findMany\", values => {\n      return Array.from(values).map(value => this.find(value)).filter(item => item != null);\n    });\n    /**\n     * Get the item based on its index\n     */\n    __publicField(this, \"at\", index => {\n      if (!this.options.groupBy && !this.options.groupSort) {\n        return this.items[index] ?? null;\n      }\n      let idx = 0;\n      const groups = this.group();\n      for (const [, items] of groups) {\n        for (const item of items) {\n          if (idx === index) return item;\n          idx++;\n        }\n      }\n      return null;\n    });\n    __publicField(this, \"sortFn\", (valueA, valueB) => {\n      const indexA = this.indexOf(valueA);\n      const indexB = this.indexOf(valueB);\n      return (indexA ?? 0) - (indexB ?? 0);\n    });\n    /**\n     * Sort the values based on their index\n     */\n    __publicField(this, \"sort\", values => {\n      return [...values].sort(this.sortFn.bind(this));\n    });\n    /**\n     * Convert an item to a value\n     */\n    __publicField(this, \"getItemValue\", item => {\n      if (item == null) return null;\n      return this.options.itemToValue?.(item) ?? fallback.itemToValue(item);\n    });\n    /**\n     * Whether an item is disabled\n     */\n    __publicField(this, \"getItemDisabled\", item => {\n      if (item == null) return false;\n      return this.options.isItemDisabled?.(item) ?? fallback.isItemDisabled(item);\n    });\n    /**\n     * Convert an item to a string\n     */\n    __publicField(this, \"stringifyItem\", item => {\n      if (item == null) return null;\n      return this.options.itemToString?.(item) ?? fallback.itemToString(item);\n    });\n    /**\n     * Convert a value to a string\n     */\n    __publicField(this, \"stringify\", value => {\n      if (value == null) return null;\n      return this.stringifyItem(this.find(value));\n    });\n    /**\n     * Convert an array of items to a string\n     */\n    __publicField(this, \"stringifyItems\", (items, separator = \", \") => {\n      return Array.from(items).map(item => this.stringifyItem(item)).filter(Boolean).join(separator);\n    });\n    /**\n     * Convert an array of items to a string\n     */\n    __publicField(this, \"stringifyMany\", (value, separator) => {\n      return this.stringifyItems(this.findMany(value), separator);\n    });\n    /**\n     * Whether the collection has a value\n     */\n    __publicField(this, \"has\", value => {\n      return this.indexOf(value) !== -1;\n    });\n    /**\n     * Whether the collection has an item\n     */\n    __publicField(this, \"hasItem\", item => {\n      if (item == null) return false;\n      return this.has(this.getItemValue(item));\n    });\n    /**\n     * Group items by the groupBy function provided in options\n     * Returns an array of [groupKey, items] tuples\n     */\n    __publicField(this, \"group\", () => {\n      const {\n        groupBy,\n        groupSort\n      } = this.options;\n      if (!groupBy) return [[\"\", [...this.items]]];\n      const groups = /* @__PURE__ */new Map();\n      this.items.forEach((item, index) => {\n        const groupKey = groupBy(item, index);\n        if (!groups.has(groupKey)) {\n          groups.set(groupKey, []);\n        }\n        groups.get(groupKey).push(item);\n      });\n      let entries = Array.from(groups.entries());\n      if (groupSort) {\n        entries.sort(([a], [b]) => {\n          if (typeof groupSort === \"function\") return groupSort(a, b);\n          if (Array.isArray(groupSort)) {\n            const indexA = groupSort.indexOf(a);\n            const indexB = groupSort.indexOf(b);\n            if (indexA === -1) return 1;\n            if (indexB === -1) return -1;\n            return indexA - indexB;\n          }\n          if (groupSort === \"asc\") return a.localeCompare(b);\n          if (groupSort === \"desc\") return b.localeCompare(a);\n          return 0;\n        });\n      }\n      return entries;\n    });\n    /**\n     * Returns the next value in the collection\n     */\n    __publicField(this, \"getNextValue\", (value, step = 1, clamp = false) => {\n      let index = this.indexOf(value);\n      if (index === -1) return null;\n      index = clamp ? Math.min(index + step, this.size - 1) : index + step;\n      while (index <= this.size && this.getItemDisabled(this.at(index))) index++;\n      return this.getItemValue(this.at(index));\n    });\n    /**\n     * Returns the previous value in the collection\n     */\n    __publicField(this, \"getPreviousValue\", (value, step = 1, clamp = false) => {\n      let index = this.indexOf(value);\n      if (index === -1) return null;\n      index = clamp ? Math.max(index - step, 0) : index - step;\n      while (index >= 0 && this.getItemDisabled(this.at(index))) index--;\n      return this.getItemValue(this.at(index));\n    });\n    /**\n     * Get the index of an item based on its key\n     */\n    __publicField(this, \"indexOf\", value => {\n      if (value == null) return -1;\n      if (!this.options.groupBy && !this.options.groupSort) {\n        return this.items.findIndex(item => this.getItemValue(item) === value);\n      }\n      let idx = 0;\n      const groups = this.group();\n      for (const [, items] of groups) {\n        for (const item of items) {\n          if (this.getItemValue(item) === value) return idx;\n          idx++;\n        }\n      }\n      return -1;\n    });\n    __publicField(this, \"getByText\", (text, current) => {\n      let items = current != null ? wrap(this.items, this.indexOf(current)) : this.items;\n      const isSingleKey = text.length === 1;\n      if (isSingleKey) items = items.filter(item => this.getItemValue(item) !== current);\n      return items.find(item => match(this.stringifyItem(item), text));\n    });\n    /**\n     * Search for a value based on a query\n     */\n    __publicField(this, \"search\", (queryString, options) => {\n      const {\n        state,\n        currentValue,\n        timeout = 350\n      } = options;\n      const search = state.keysSoFar + queryString;\n      const isRepeated = search.length > 1 && Array.from(search).every(char => char === search[0]);\n      const query = isRepeated ? search[0] : search;\n      const item = this.getByText(query, currentValue);\n      const value = this.getItemValue(item);\n      function cleanup() {\n        clearTimeout(state.timer);\n        state.timer = -1;\n      }\n      function update(value2) {\n        state.keysSoFar = value2;\n        cleanup();\n        if (value2 !== \"\") {\n          state.timer = +setTimeout(() => {\n            update(\"\");\n            cleanup();\n          }, timeout);\n        }\n      }\n      update(search);\n      return value;\n    });\n    /**\n     * Update an item in the collection\n     */\n    __publicField(this, \"update\", (value, item) => {\n      let index = this.items.findIndex(item2 => this.getItemValue(item2) === value);\n      if (index === -1) return this;\n      return this.copy([...this.items.slice(0, index), item, ...this.items.slice(index + 1)]);\n    });\n    /**\n     * Insert items at a specific index\n     */\n    __publicField(this, \"insert\", (index, ...items) => {\n      return this.copy(insert(this.items, index, ...items));\n    });\n    /**\n     * Insert items before a specific value\n     */\n    __publicField(this, \"insertBefore\", (value, ...items) => {\n      let toIndex = this.indexOf(value);\n      if (toIndex === -1) {\n        if (this.items.length === 0) toIndex = 0;else return this;\n      }\n      return this.copy(insert(this.items, toIndex, ...items));\n    });\n    /**\n     * Insert items after a specific value\n     */\n    __publicField(this, \"insertAfter\", (value, ...items) => {\n      let toIndex = this.indexOf(value);\n      if (toIndex === -1) {\n        if (this.items.length === 0) toIndex = 0;else return this;\n      }\n      return this.copy(insert(this.items, toIndex + 1, ...items));\n    });\n    /**\n     * Prepend items to the collection\n     */\n    __publicField(this, \"prepend\", (...items) => {\n      return this.copy(insert(this.items, 0, ...items));\n    });\n    /**\n     * Append items to the collection\n     */\n    __publicField(this, \"append\", (...items) => {\n      return this.copy(insert(this.items, this.items.length, ...items));\n    });\n    /**\n     * Filter the collection\n     */\n    __publicField(this, \"filter\", fn => {\n      const filteredItems = this.items.filter((item, index) => fn(this.stringifyItem(item), index));\n      return this.copy(filteredItems);\n    });\n    /**\n     * Remove items from the collection\n     */\n    __publicField(this, \"remove\", (...itemsOrValues) => {\n      const values = itemsOrValues.map(itemOrValue => typeof itemOrValue === \"string\" ? itemOrValue : this.getItemValue(itemOrValue));\n      return this.copy(this.items.filter(item => {\n        const value = this.getItemValue(item);\n        if (value == null) return false;\n        return !values.includes(value);\n      }));\n    });\n    /**\n     * Move an item to a specific index\n     */\n    __publicField(this, \"move\", (value, toIndex) => {\n      const fromIndex = this.indexOf(value);\n      if (fromIndex === -1) return this;\n      return this.copy(move(this.items, [fromIndex], toIndex));\n    });\n    /**\n     * Move items before a specific value\n     */\n    __publicField(this, \"moveBefore\", (value, ...values) => {\n      let toIndex = this.items.findIndex(item => this.getItemValue(item) === value);\n      if (toIndex === -1) return this;\n      let indices = values.map(value2 => this.items.findIndex(item => this.getItemValue(item) === value2)).sort((a, b) => a - b);\n      return this.copy(move(this.items, indices, toIndex));\n    });\n    /**\n     * Move items after a specific value\n     */\n    __publicField(this, \"moveAfter\", (value, ...values) => {\n      let toIndex = this.items.findIndex(item => this.getItemValue(item) === value);\n      if (toIndex === -1) return this;\n      let indices = values.map(value2 => this.items.findIndex(item => this.getItemValue(item) === value2)).sort((a, b) => a - b);\n      return this.copy(move(this.items, indices, toIndex + 1));\n    });\n    /**\n     * Reorder items\n     */\n    __publicField(this, \"reorder\", (fromIndex, toIndex) => {\n      return this.copy(move(this.items, [fromIndex], toIndex));\n    });\n    /**\n     * Compare two values\n     */\n    __publicField(this, \"compareValue\", (a, b) => {\n      const indexA = this.indexOf(a);\n      const indexB = this.indexOf(b);\n      if (indexA < indexB) return -1;\n      if (indexA > indexB) return 1;\n      return 0;\n    });\n    /**\n     * Get the range of values between two values\n     */\n    __publicField(this, \"range\", (from, to) => {\n      let keys = [];\n      let key = from;\n      while (key != null) {\n        let item = this.find(key);\n        if (item) keys.push(key);\n        if (key === to) return keys;\n        key = this.getNextValue(key);\n      }\n      return [];\n    });\n    /**\n     * Get the range of values between two values\n     */\n    __publicField(this, \"getValueRange\", (from, to) => {\n      if (from && to) {\n        if (this.compareValue(from, to) <= 0) {\n          return this.range(from, to);\n        }\n        return this.range(to, from);\n      }\n      return [];\n    });\n    /**\n     * Convert the collection to a string\n     */\n    __publicField(this, \"toString\", () => {\n      let result = \"\";\n      for (const item of this.items) {\n        const value = this.getItemValue(item);\n        const label = this.stringifyItem(item);\n        const disabled = this.getItemDisabled(item);\n        const itemString = [value, label, disabled].filter(Boolean).join(\":\");\n        result += itemString + \",\";\n      }\n      return result;\n    });\n    /**\n     * Convert the collection to a JSON object\n     */\n    __publicField(this, \"toJSON\", () => {\n      return {\n        size: this.size,\n        first: this.firstValue,\n        last: this.lastValue\n      };\n    });\n    this.items = [...options.items];\n  }\n  /**\n   * Returns the number of items in the collection\n   */\n  get size() {\n    return this.items.length;\n  }\n  /**\n   * Returns the first value in the collection\n   */\n  get firstValue() {\n    let index = 0;\n    while (this.getItemDisabled(this.at(index))) index++;\n    return this.getItemValue(this.at(index));\n  }\n  /**\n   * Returns the last value in the collection\n   */\n  get lastValue() {\n    let index = this.size - 1;\n    while (this.getItemDisabled(this.at(index))) index--;\n    return this.getItemValue(this.at(index));\n  }\n  *[Symbol.iterator]() {\n    yield* this.items;\n  }\n};\nvar match = (label, query) => {\n  return !!label?.toLowerCase().startsWith(query.toLowerCase());\n};\nvar wrap = (v, idx) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);\n};\nfunction isListCollection(v) {\n  return v instanceof ListCollection;\n}\nfunction insert(items, index, ...values) {\n  return [...items.slice(0, index), ...values, ...items.slice(index)];\n}\nfunction move(items, indices, toIndex) {\n  indices = [...indices].sort((a, b) => a - b);\n  const itemsToMove = indices.map(i => items[i]);\n  for (let i = indices.length - 1; i >= 0; i--) {\n    items = [...items.slice(0, indices[i]), ...items.slice(indices[i] + 1)];\n  }\n  toIndex = Math.max(0, toIndex - indices.filter(i => i < toIndex).length);\n  return [...items.slice(0, toIndex), ...itemsToMove, ...items.slice(toIndex)];\n}\n\n// src/grid-collection.ts\nvar GridCollection = class extends ListCollection {\n  constructor(options) {\n    const {\n      columnCount\n    } = options;\n    super(options);\n    __publicField(this, \"columnCount\");\n    /**\n     * Returns the row data in the grid\n     */\n    __publicField(this, \"getRows\", () => {\n      return chunk([...this.items], this.columnCount);\n    });\n    /**\n     * Returns the number of rows in the grid\n     */\n    __publicField(this, \"getRowCount\", () => {\n      return this.getRows().length;\n    });\n    /**\n     * Returns the index of the specified row and column in the grid\n     */\n    __publicField(this, \"getCellIndex\", (row, column) => {\n      return row * this.columnCount + column;\n    });\n    /**\n     * Returns the item at the specified row and column in the grid\n     */\n    __publicField(this, \"getCell\", (row, column) => {\n      return this.at(this.getCellIndex(row, column));\n    });\n    /**\n     * Returns the row and column index for a given value\n     */\n    __publicField(this, \"getValueCell\", value => {\n      const index = this.indexOf(value);\n      if (index === -1) return null;\n      const row = Math.floor(index / this.columnCount);\n      const column = index % this.columnCount;\n      return {\n        row,\n        column\n      };\n    });\n    /**\n     * Returns the value of the last enabled column in a row\n     */\n    __publicField(this, \"getLastEnabledColumnIndex\", row => {\n      for (let col = this.columnCount - 1; col >= 0; col--) {\n        const cell = this.getCell(row, col);\n        if (cell && !this.getItemDisabled(cell)) {\n          return col;\n        }\n      }\n      return null;\n    });\n    /**\n     * Returns the index of the first enabled column in a row\n     */\n    __publicField(this, \"getFirstEnabledColumnIndex\", row => {\n      for (let col = 0; col < this.columnCount; col++) {\n        const cell = this.getCell(row, col);\n        if (cell && !this.getItemDisabled(cell)) {\n          return col;\n        }\n      }\n      return null;\n    });\n    /**\n     * Returns the value of the previous row in the grid, based on the current value\n     */\n    __publicField(this, \"getPreviousRowValue\", (value, loop = false) => {\n      const currentCell = this.getValueCell(value);\n      if (currentCell === null) return null;\n      const rows = this.getRows();\n      const rowCount = this.getRowCount();\n      let prevRowIndex = currentCell.row;\n      let prevColumnIndex = currentCell.column;\n      for (let i = 1; i <= rowCount; i++) {\n        prevRowIndex = prevIndex(rows, prevRowIndex, {\n          loop\n        });\n        const prevRow = rows[prevRowIndex];\n        if (!prevRow) continue;\n        const prevCell = prevRow[prevColumnIndex];\n        if (!prevCell) {\n          const lastColumnIndex = this.getLastEnabledColumnIndex(prevRowIndex);\n          if (lastColumnIndex != null) {\n            prevColumnIndex = lastColumnIndex;\n          }\n        }\n        const cell = this.getCell(prevRowIndex, prevColumnIndex);\n        if (!this.getItemDisabled(cell)) {\n          return this.getItemValue(cell);\n        }\n      }\n      return this.firstValue;\n    });\n    /**\n     * Returns the value of the next row in the grid, based on the current value\n     */\n    __publicField(this, \"getNextRowValue\", (value, loop = false) => {\n      const currentCell = this.getValueCell(value);\n      if (currentCell === null) return null;\n      const rows = this.getRows();\n      const rowCount = this.getRowCount();\n      let nextRowIndex = currentCell.row;\n      let nextColumnIndex = currentCell.column;\n      for (let i = 1; i <= rowCount; i++) {\n        nextRowIndex = nextIndex(rows, nextRowIndex, {\n          loop\n        });\n        const nextRow = rows[nextRowIndex];\n        if (!nextRow) continue;\n        const nextCell = nextRow[nextColumnIndex];\n        if (!nextCell) {\n          const lastColumnIndex = this.getLastEnabledColumnIndex(nextRowIndex);\n          if (lastColumnIndex != null) {\n            nextColumnIndex = lastColumnIndex;\n          }\n        }\n        const cell = this.getCell(nextRowIndex, nextColumnIndex);\n        if (!this.getItemDisabled(cell)) {\n          return this.getItemValue(cell);\n        }\n      }\n      return this.lastValue;\n    });\n    this.columnCount = columnCount;\n  }\n};\nfunction isGridCollection(v) {\n  return v instanceof GridCollection;\n}\n\n// src/tree-visit.ts\nfunction access(node, indexPath, options) {\n  for (let i = 0; i < indexPath.length; i++) node = options.getChildren(node, indexPath.slice(i + 1))[indexPath[i]];\n  return node;\n}\nfunction ancestorIndexPaths(indexPaths) {\n  const sortedPaths = sortIndexPaths(indexPaths);\n  const result = [];\n  const seen = /* @__PURE__ */new Set();\n  for (const indexPath of sortedPaths) {\n    const key = indexPath.join();\n    if (!seen.has(key)) {\n      seen.add(key);\n      result.push(indexPath);\n    }\n  }\n  return result;\n}\nfunction compareIndexPaths(a, b) {\n  for (let i = 0; i < Math.min(a.length, b.length); i++) {\n    if (a[i] < b[i]) return -1;\n    if (a[i] > b[i]) return 1;\n  }\n  return a.length - b.length;\n}\nfunction sortIndexPaths(indexPaths) {\n  return indexPaths.sort(compareIndexPaths);\n}\nfunction find(node, options) {\n  let found;\n  visit(node, {\n    ...options,\n    onEnter: (child, indexPath) => {\n      if (options.predicate(child, indexPath)) {\n        found = child;\n        return \"stop\";\n      }\n    }\n  });\n  return found;\n}\nfunction findIndexPath(node, options) {\n  let found;\n  visit(node, {\n    onEnter: (child, indexPath) => {\n      if (options.predicate(child, indexPath)) {\n        found = [...indexPath];\n        return \"stop\";\n      }\n    },\n    getChildren: options.getChildren\n  });\n  return found;\n}\nfunction reduce(node, options) {\n  let result = options.initialResult;\n  visit(node, {\n    ...options,\n    onEnter: (child, indexPath) => {\n      result = options.nextResult(result, child, indexPath);\n    }\n  });\n  return result;\n}\nfunction flatMap(node, options) {\n  return reduce(node, {\n    ...options,\n    initialResult: [],\n    nextResult: (result, child, indexPath) => {\n      result.push(...options.transform(child, indexPath));\n      return result;\n    }\n  });\n}\nfunction insertOperation(index, nodes) {\n  return {\n    type: \"insert\",\n    index,\n    nodes\n  };\n}\nfunction removeOperation(indexes) {\n  return {\n    type: \"remove\",\n    indexes\n  };\n}\nfunction replaceOperation() {\n  return {\n    type: \"replace\"\n  };\n}\nfunction splitIndexPath(indexPath) {\n  return [indexPath.slice(0, -1), indexPath[indexPath.length - 1]];\n}\nfunction getInsertionOperations(indexPath, nodes, operations = /* @__PURE__ */new Map()) {\n  const [parentIndexPath, index] = splitIndexPath(indexPath);\n  for (let i = parentIndexPath.length - 1; i >= 0; i--) {\n    const parentKey = parentIndexPath.slice(0, i).join();\n    switch (operations.get(parentKey)?.type) {\n      case \"remove\":\n        continue;\n    }\n    operations.set(parentKey, replaceOperation());\n  }\n  const operation = operations.get(parentIndexPath.join());\n  switch (operation?.type) {\n    case \"remove\":\n      operations.set(parentIndexPath.join(), {\n        type: \"removeThenInsert\",\n        removeIndexes: operation.indexes,\n        insertIndex: index,\n        insertNodes: nodes\n      });\n      break;\n    default:\n      operations.set(parentIndexPath.join(), insertOperation(index, nodes));\n  }\n  return operations;\n}\nfunction getRemovalOperations(indexPaths) {\n  const operations = /* @__PURE__ */new Map();\n  const indexesToRemove = /* @__PURE__ */new Map();\n  for (const indexPath of indexPaths) {\n    const parentKey = indexPath.slice(0, -1).join();\n    const value = indexesToRemove.get(parentKey) ?? [];\n    value.push(indexPath[indexPath.length - 1]);\n    indexesToRemove.set(parentKey, value.sort((a, b) => a - b));\n  }\n  for (const indexPath of indexPaths) {\n    for (let i = indexPath.length - 2; i >= 0; i--) {\n      const parentKey = indexPath.slice(0, i).join();\n      if (!operations.has(parentKey)) {\n        operations.set(parentKey, replaceOperation());\n      }\n    }\n  }\n  for (const [parentKey, indexes] of indexesToRemove) {\n    operations.set(parentKey, removeOperation(indexes));\n  }\n  return operations;\n}\nfunction getReplaceOperations(indexPath, node) {\n  const operations = /* @__PURE__ */new Map();\n  const [parentIndexPath, index] = splitIndexPath(indexPath);\n  for (let i = parentIndexPath.length - 1; i >= 0; i--) {\n    const parentKey = parentIndexPath.slice(0, i).join();\n    operations.set(parentKey, replaceOperation());\n  }\n  operations.set(parentIndexPath.join(), {\n    type: \"removeThenInsert\",\n    removeIndexes: [index],\n    insertIndex: index,\n    insertNodes: [node]\n  });\n  return operations;\n}\nfunction mutate(node, operations, options) {\n  return map(node, {\n    ...options,\n    getChildren: (node2, indexPath) => {\n      const key = indexPath.join();\n      const operation = operations.get(key);\n      switch (operation?.type) {\n        case \"replace\":\n        case \"remove\":\n        case \"removeThenInsert\":\n        case \"insert\":\n          return options.getChildren(node2, indexPath);\n        default:\n          return [];\n      }\n    },\n    transform: (node2, children, indexPath) => {\n      const key = indexPath.join();\n      const operation = operations.get(key);\n      switch (operation?.type) {\n        case \"remove\":\n          return options.create(node2, children.filter((_, index) => !operation.indexes.includes(index)), indexPath);\n        case \"removeThenInsert\":\n          const updatedChildren = children.filter((_, index) => !operation.removeIndexes.includes(index));\n          const adjustedIndex = operation.removeIndexes.reduce((index, removedIndex) => removedIndex < index ? index - 1 : index, operation.insertIndex);\n          return options.create(node2, splice(updatedChildren, adjustedIndex, 0, ...operation.insertNodes), indexPath);\n        case \"insert\":\n          return options.create(node2, splice(children, operation.index, 0, ...operation.nodes), indexPath);\n        case \"replace\":\n          return options.create(node2, children, indexPath);\n        default:\n          return node2;\n      }\n    }\n  });\n}\nfunction splice(array, start, deleteCount, ...items) {\n  return [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)];\n}\nfunction map(node, options) {\n  const childrenMap = {};\n  visit(node, {\n    ...options,\n    onLeave: (child, indexPath) => {\n      const keyIndexPath = [0, ...indexPath];\n      const key = keyIndexPath.join();\n      const transformed = options.transform(child, childrenMap[key] ?? [], indexPath);\n      const parentKey = keyIndexPath.slice(0, -1).join();\n      const parentChildren = childrenMap[parentKey] ?? [];\n      parentChildren.push(transformed);\n      childrenMap[parentKey] = parentChildren;\n    }\n  });\n  return childrenMap[\"\"][0];\n}\nfunction insert2(node, options) {\n  const {\n    nodes,\n    at\n  } = options;\n  if (at.length === 0) throw new Error(`Can't insert nodes at the root`);\n  const state = getInsertionOperations(at, nodes);\n  return mutate(node, state, options);\n}\nfunction replace(node, options) {\n  if (options.at.length === 0) return options.node;\n  const operations = getReplaceOperations(options.at, options.node);\n  return mutate(node, operations, options);\n}\nfunction remove(node, options) {\n  if (options.indexPaths.length === 0) return node;\n  for (const indexPath of options.indexPaths) {\n    if (indexPath.length === 0) throw new Error(`Can't remove the root node`);\n  }\n  const operations = getRemovalOperations(options.indexPaths);\n  return mutate(node, operations, options);\n}\nfunction move2(node, options) {\n  if (options.indexPaths.length === 0) return node;\n  for (const indexPath of options.indexPaths) {\n    if (indexPath.length === 0) throw new Error(`Can't move the root node`);\n  }\n  if (options.to.length === 0) throw new Error(`Can't move nodes to the root`);\n  const _ancestorIndexPaths = ancestorIndexPaths(options.indexPaths);\n  const nodesToInsert = _ancestorIndexPaths.map(indexPath => access(node, indexPath, options));\n  const operations = getInsertionOperations(options.to, nodesToInsert, getRemovalOperations(_ancestorIndexPaths));\n  return mutate(node, operations, options);\n}\nfunction visit(node, options) {\n  const {\n    onEnter,\n    onLeave,\n    getChildren\n  } = options;\n  let indexPath = [];\n  let stack = [{\n    node\n  }];\n  const getIndexPath = options.reuseIndexPath ? () => indexPath : () => indexPath.slice();\n  while (stack.length > 0) {\n    let wrapper = stack[stack.length - 1];\n    if (wrapper.state === void 0) {\n      const enterResult = onEnter?.(wrapper.node, getIndexPath());\n      if (enterResult === \"stop\") return;\n      wrapper.state = enterResult === \"skip\" ? -1 : 0;\n    }\n    const children = wrapper.children || getChildren(wrapper.node, getIndexPath());\n    wrapper.children || (wrapper.children = children);\n    if (wrapper.state !== -1) {\n      if (wrapper.state < children.length) {\n        let currentIndex = wrapper.state;\n        indexPath.push(currentIndex);\n        stack.push({\n          node: children[currentIndex]\n        });\n        wrapper.state = currentIndex + 1;\n        continue;\n      }\n      const leaveResult = onLeave?.(wrapper.node, getIndexPath());\n      if (leaveResult === \"stop\") return;\n    }\n    indexPath.pop();\n    stack.pop();\n  }\n}\n\n// src/tree-collection.ts\nvar TreeCollection = class {\n  constructor(options) {\n    this.options = options;\n    __publicField(this, \"rootNode\");\n    __publicField(this, \"isEqual\", other => {\n      return isEqual(this.rootNode, other.rootNode);\n    });\n    __publicField(this, \"getNodeChildren\", node => {\n      return this.options.nodeToChildren?.(node) ?? fallback2.nodeToChildren(node) ?? [];\n    });\n    __publicField(this, \"getNodeValue\", node => {\n      return this.options.nodeToValue?.(node) ?? fallback2.nodeToValue(node);\n    });\n    __publicField(this, \"getNodeDisabled\", node => {\n      return this.options.isNodeDisabled?.(node) ?? fallback2.isNodeDisabled(node);\n    });\n    __publicField(this, \"stringify\", value => {\n      const node = this.findNode(value);\n      if (!node) return null;\n      return this.stringifyNode(node);\n    });\n    __publicField(this, \"stringifyNode\", node => {\n      return this.options.nodeToString?.(node) ?? fallback2.nodeToString(node);\n    });\n    __publicField(this, \"getFirstNode\", (rootNode = this.rootNode) => {\n      let firstChild;\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (!firstChild && indexPath.length > 0 && !this.getNodeDisabled(node)) {\n            firstChild = node;\n            return \"stop\";\n          }\n        }\n      });\n      return firstChild;\n    });\n    __publicField(this, \"getLastNode\", (rootNode = this.rootNode, opts = {}) => {\n      let lastChild;\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({\n            value: nodeValue,\n            node,\n            indexPath\n          })) return \"skip\";\n          if (indexPath.length > 1) return \"skip\";\n          if (!this.getNodeDisabled(node)) {\n            lastChild = node;\n          }\n        }\n      });\n      return lastChild;\n    });\n    __publicField(this, \"at\", indexPath => {\n      return access(this.rootNode, indexPath, {\n        getChildren: this.getNodeChildren\n      });\n    });\n    __publicField(this, \"findNode\", (value, rootNode = this.rootNode) => {\n      return find(rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: node => this.getNodeValue(node) === value\n      });\n    });\n    __publicField(this, \"sort\", values => {\n      return values.reduce((acc, value) => {\n        const indexPath = this.getIndexPath(value);\n        if (indexPath != null) acc.push({\n          value,\n          indexPath\n        });\n        return acc;\n      }, []).sort((a, b) => compareIndexPaths(a.indexPath, b.indexPath)).map(({\n        value\n      }) => value);\n    });\n    __publicField(this, \"getIndexPath\", value => {\n      return findIndexPath(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: node => this.getNodeValue(node) === value\n      });\n    });\n    __publicField(this, \"getValue\", indexPath => {\n      const node = this.at(indexPath);\n      return node ? this.getNodeValue(node) : void 0;\n    });\n    __publicField(this, \"getValuePath\", indexPath => {\n      if (!indexPath) return [];\n      const valuePath = [];\n      let currentPath = [...indexPath];\n      while (currentPath.length > 0) {\n        const node = this.at(currentPath);\n        if (node) valuePath.unshift(this.getNodeValue(node));\n        currentPath.pop();\n      }\n      return valuePath;\n    });\n    __publicField(this, \"getDepth\", value => {\n      const indexPath = findIndexPath(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: node => this.getNodeValue(node) === value\n      });\n      return indexPath?.length ?? 0;\n    });\n    __publicField(this, \"isRootNode\", node => {\n      return this.getNodeValue(node) === this.getNodeValue(this.rootNode);\n    });\n    __publicField(this, \"contains\", (parentIndexPath, valueIndexPath) => {\n      if (!parentIndexPath || !valueIndexPath) return false;\n      return valueIndexPath.slice(0, parentIndexPath.length).every((_, i) => parentIndexPath[i] === valueIndexPath[i]);\n    });\n    __publicField(this, \"getNextNode\", (value, opts = {}) => {\n      let found = false;\n      let nextNode;\n      visit(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({\n            value: nodeValue,\n            node,\n            indexPath\n          })) {\n            if (nodeValue === value) {\n              found = true;\n            }\n            return \"skip\";\n          }\n          if (found && !this.getNodeDisabled(node)) {\n            nextNode = node;\n            return \"stop\";\n          }\n          if (nodeValue === value) {\n            found = true;\n          }\n        }\n      });\n      return nextNode;\n    });\n    __publicField(this, \"getPreviousNode\", (value, opts = {}) => {\n      let previousNode;\n      let found = false;\n      visit(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({\n            value: nodeValue,\n            node,\n            indexPath\n          })) {\n            return \"skip\";\n          }\n          if (nodeValue === value) {\n            found = true;\n            return \"stop\";\n          }\n          if (!this.getNodeDisabled(node)) {\n            previousNode = node;\n          }\n        }\n      });\n      return found ? previousNode : void 0;\n    });\n    __publicField(this, \"getParentNodes\", values => {\n      const result = [];\n      let indexPath = this.getIndexPath(values);\n      while (indexPath && indexPath.length > 0) {\n        indexPath.pop();\n        const parentNode = this.at(indexPath);\n        if (parentNode && !this.isRootNode(parentNode)) {\n          result.unshift(parentNode);\n        }\n      }\n      return result;\n    });\n    __publicField(this, \"getParentIndexPath\", indexPath => {\n      return indexPath.slice(0, -1);\n    });\n    __publicField(this, \"getParentNode\", valueOrIndexPath => {\n      const indexPath = typeof valueOrIndexPath === \"string\" ? this.getIndexPath(valueOrIndexPath) : valueOrIndexPath;\n      return indexPath ? this.at(this.getParentIndexPath(indexPath)) : void 0;\n    });\n    __publicField(this, \"visit\", opts => {\n      const {\n        skip,\n        ...rest\n      } = opts;\n      visit(this.rootNode, {\n        ...rest,\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          if (skip?.({\n            value: this.getNodeValue(node),\n            node,\n            indexPath\n          })) return \"skip\";\n          return rest.onEnter?.(node, indexPath);\n        }\n      });\n    });\n    __publicField(this, \"getPreviousSibling\", indexPath => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const siblings = this.getNodeChildren(parentNode);\n      let idx = siblings.findIndex(sibling => this.getValue(indexPath) === this.getNodeValue(sibling));\n      while (--idx >= 0) {\n        const sibling = siblings[idx];\n        if (!this.getNodeDisabled(sibling)) return sibling;\n      }\n      return;\n    });\n    __publicField(this, \"getNextSibling\", indexPath => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const siblings = this.getNodeChildren(parentNode);\n      let idx = siblings.findIndex(sibling => this.getValue(indexPath) === this.getNodeValue(sibling));\n      while (++idx < siblings.length) {\n        const sibling = siblings[idx];\n        if (!this.getNodeDisabled(sibling)) return sibling;\n      }\n      return;\n    });\n    __publicField(this, \"getSiblingNodes\", indexPath => {\n      const parentNode = this.getParentNode(indexPath);\n      return parentNode ? this.getNodeChildren(parentNode) : [];\n    });\n    __publicField(this, \"getValues\", (rootNode = this.rootNode) => {\n      const values = flatMap(rootNode, {\n        getChildren: this.getNodeChildren,\n        transform: node => [this.getNodeValue(node)]\n      });\n      return values.slice(1);\n    });\n    __publicField(this, \"isSameDepth\", (indexPath, depth) => {\n      if (depth == null) return true;\n      return indexPath.length === depth;\n    });\n    __publicField(this, \"isBranchNode\", node => {\n      return this.getNodeChildren(node).length > 0;\n    });\n    __publicField(this, \"getBranchValues\", (rootNode = this.rootNode, opts = {}) => {\n      let values = [];\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({\n            value: nodeValue,\n            node,\n            indexPath\n          })) return \"skip\";\n          if (this.getNodeChildren(node).length > 0 && this.isSameDepth(indexPath, opts.depth)) {\n            values.push(this.getNodeValue(node));\n          }\n        }\n      });\n      return values.slice(1);\n    });\n    __publicField(this, \"flatten\", (rootNode = this.rootNode) => {\n      const nodes = flatMap(rootNode, {\n        getChildren: this.getNodeChildren,\n        transform: (node, indexPath) => {\n          const children = this.getNodeChildren(node).map(child => this.getNodeValue(child));\n          return [compact({\n            label: this.stringifyNode(node),\n            value: this.getNodeValue(node),\n            indexPath,\n            children: children.length > 0 ? children : void 0\n          })];\n        }\n      });\n      return nodes.slice(1);\n    });\n    __publicField(this, \"_create\", (node, children) => {\n      return compact({\n        ...node,\n        children\n      });\n    });\n    __publicField(this, \"_insert\", (rootNode, indexPath, nodes) => {\n      return insert2(rootNode, {\n        at: indexPath,\n        nodes,\n        getChildren: this.getNodeChildren,\n        create: this._create\n      });\n    });\n    __publicField(this, \"_replace\", (rootNode, indexPath, node) => {\n      return replace(rootNode, {\n        at: indexPath,\n        node,\n        getChildren: this.getNodeChildren,\n        create: this._create\n      });\n    });\n    __publicField(this, \"_move\", (rootNode, indexPaths, to) => {\n      return move2(rootNode, {\n        indexPaths,\n        to,\n        getChildren: this.getNodeChildren,\n        create: this._create\n      });\n    });\n    __publicField(this, \"_remove\", (rootNode, indexPaths) => {\n      return remove(rootNode, {\n        indexPaths,\n        getChildren: this.getNodeChildren,\n        create: this._create\n      });\n    });\n    __publicField(this, \"replace\", (indexPath, node) => {\n      return this._replace(this.rootNode, indexPath, node);\n    });\n    __publicField(this, \"remove\", indexPaths => {\n      return this._remove(this.rootNode, indexPaths);\n    });\n    __publicField(this, \"insertBefore\", (indexPath, nodes) => {\n      const parentNode = this.getParentNode(indexPath);\n      return parentNode ? this._insert(this.rootNode, indexPath, nodes) : void 0;\n    });\n    __publicField(this, \"insertAfter\", (indexPath, nodes) => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const nextIndex2 = [...indexPath.slice(0, -1), indexPath[indexPath.length - 1] + 1];\n      return this._insert(this.rootNode, nextIndex2, nodes);\n    });\n    __publicField(this, \"move\", (fromIndexPaths, toIndexPath) => {\n      return this._move(this.rootNode, fromIndexPaths, toIndexPath);\n    });\n    __publicField(this, \"toJSON\", () => {\n      return this.getValues(this.rootNode);\n    });\n    this.rootNode = options.rootNode;\n  }\n};\nfunction flattenedToTree(nodes) {\n  let rootNode = {\n    value: \"ROOT\"\n  };\n  nodes.map(node => {\n    const {\n      indexPath,\n      label,\n      value\n    } = node;\n    if (!indexPath.length) {\n      Object.assign(rootNode, {\n        label,\n        value,\n        children: []\n      });\n      return;\n    }\n    rootNode = insert2(rootNode, {\n      at: indexPath,\n      nodes: [compact({\n        label,\n        value\n      })],\n      getChildren: node2 => node2.children ?? [],\n      create: (node2, children) => {\n        return compact({\n          ...node2,\n          children\n        });\n      }\n    });\n  });\n  return new TreeCollection({\n    rootNode\n  });\n}\nfunction filePathToTree(paths) {\n  const rootNode = {\n    label: \"\",\n    value: \"ROOT\",\n    children: []\n  };\n  paths.forEach(path => {\n    const parts = path.split(\"/\");\n    let currentNode = rootNode;\n    parts.forEach(part => {\n      let childNode = currentNode.children?.find(child => child.label === part);\n      if (!childNode) {\n        childNode = {\n          value: parts.slice(0, parts.indexOf(part) + 1).join(\"/\"),\n          label: part\n        };\n        currentNode.children || (currentNode.children = []);\n        currentNode.children.push(childNode);\n      }\n      currentNode = childNode;\n    });\n  });\n  return new TreeCollection({\n    rootNode\n  });\n}\nvar fallback2 = {\n  nodeToValue(node) {\n    if (typeof node === \"string\") return node;\n    if (isObject(node) && hasProp(node, \"value\")) return node.value;\n    return \"\";\n  },\n  nodeToString(node) {\n    if (typeof node === \"string\") return node;\n    if (isObject(node) && hasProp(node, \"label\")) return node.label;\n    return fallback2.nodeToValue(node);\n  },\n  isNodeDisabled(node) {\n    if (isObject(node) && hasProp(node, \"disabled\")) return !!node.disabled;\n    return false;\n  },\n  nodeToChildren(node) {\n    return node.children;\n  }\n};\nvar Selection = class _Selection extends Set {\n  constructor(values = []) {\n    super(values);\n    __publicField(this, \"selectionMode\", \"single\");\n    __publicField(this, \"deselectable\", true);\n    __publicField(this, \"copy\", () => {\n      const clone = new _Selection([...this]);\n      return this.sync(clone);\n    });\n    __publicField(this, \"sync\", other => {\n      other.selectionMode = this.selectionMode;\n      other.deselectable = this.deselectable;\n      return other;\n    });\n    __publicField(this, \"isEmpty\", () => {\n      return this.size === 0;\n    });\n    __publicField(this, \"isSelected\", value => {\n      if (this.selectionMode === \"none\" || value == null) {\n        return false;\n      }\n      return this.has(value);\n    });\n    __publicField(this, \"canSelect\", (collection, value) => {\n      return this.selectionMode !== \"none\" || !collection.getItemDisabled(collection.find(value));\n    });\n    __publicField(this, \"firstSelectedValue\", collection => {\n      let firstValue = null;\n      for (let value of this) {\n        if (!firstValue || collection.compareValue(value, firstValue) < 0) {\n          firstValue = value;\n        }\n      }\n      return firstValue;\n    });\n    __publicField(this, \"lastSelectedValue\", collection => {\n      let lastValue = null;\n      for (let value of this) {\n        if (!lastValue || collection.compareValue(value, lastValue) > 0) {\n          lastValue = value;\n        }\n      }\n      return lastValue;\n    });\n    __publicField(this, \"extendSelection\", (collection, anchorValue, targetValue) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      if (this.selectionMode === \"single\") {\n        return this.replaceSelection(collection, targetValue);\n      }\n      const selection = this.copy();\n      const lastSelected = Array.from(this).pop();\n      for (let key of collection.getValueRange(anchorValue, lastSelected ?? targetValue)) {\n        selection.delete(key);\n      }\n      for (let key of collection.getValueRange(targetValue, anchorValue)) {\n        if (this.canSelect(collection, key)) {\n          selection.add(key);\n        }\n      }\n      return selection;\n    });\n    __publicField(this, \"toggleSelection\", (collection, value) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      if (this.selectionMode === \"single\" && !this.isSelected(value)) {\n        return this.replaceSelection(collection, value);\n      }\n      const selection = this.copy();\n      if (selection.has(value)) {\n        selection.delete(value);\n      } else if (selection.canSelect(collection, value)) {\n        selection.add(value);\n      }\n      return selection;\n    });\n    __publicField(this, \"replaceSelection\", (collection, value) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      if (value == null) {\n        return this;\n      }\n      if (!this.canSelect(collection, value)) {\n        return this;\n      }\n      const selection = new _Selection([value]);\n      return this.sync(selection);\n    });\n    __publicField(this, \"setSelection\", values => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      let selection = new _Selection();\n      for (let value of values) {\n        if (value != null) {\n          selection.add(value);\n          if (this.selectionMode === \"single\") {\n            break;\n          }\n        }\n      }\n      return this.sync(selection);\n    });\n    __publicField(this, \"clearSelection\", () => {\n      const selection = this.copy();\n      if (selection.deselectable && selection.size > 0) {\n        selection.clear();\n      }\n      return selection;\n    });\n    __publicField(this, \"select\", (collection, value, forceToggle) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      if (this.selectionMode === \"single\") {\n        if (this.isSelected(value) && this.deselectable) {\n          return this.toggleSelection(collection, value);\n        } else {\n          return this.replaceSelection(collection, value);\n        }\n      } else if (this.selectionMode === \"multiple\" || forceToggle) {\n        return this.toggleSelection(collection, value);\n      } else {\n        return this.replaceSelection(collection, value);\n      }\n    });\n    __publicField(this, \"deselect\", value => {\n      const selection = this.copy();\n      selection.delete(value);\n      return selection;\n    });\n    __publicField(this, \"isEqual\", other => {\n      return isEqual(Array.from(this), Array.from(other));\n    });\n  }\n};\nexport { GridCollection, ListCollection, Selection, TreeCollection, filePathToTree, flattenedToTree, isGridCollection, isListCollection };","map":{"version":3,"names":["compact","isEqual","chunk","prevIndex","nextIndex","isObject","hasProp","__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","fallback","itemToValue","item","itemToString","label","isItemDisabled","disabled","ListCollection","_ListCollection","constructor","options","items","other","copy","Array","from","map","getItemValue","filter","Boolean","index","indexOf","at","values","find","groupBy","groupSort","idx","groups","group","valueA","valueB","indexA","indexB","sort","sortFn","bind","stringifyItem","separator","join","stringifyItems","findMany","has","Map","forEach","groupKey","set","get","push","entries","a","b","isArray","localeCompare","step","clamp","Math","min","size","getItemDisabled","max","findIndex","text","current","wrap","isSingleKey","length","match","queryString","state","currentValue","timeout","search","keysSoFar","isRepeated","every","char","query","getByText","cleanup","clearTimeout","timer","update","value2","setTimeout","item2","slice","insert","toIndex","fn","filteredItems","itemsOrValues","itemOrValue","includes","fromIndex","move","indices","to","keys","getNextValue","compareValue","range","result","itemString","first","firstValue","last","lastValue","Symbol","iterator","toLowerCase","startsWith","v","_","isListCollection","itemsToMove","i","GridCollection","columnCount","getRows","row","column","getCellIndex","floor","col","cell","getCell","loop","currentCell","getValueCell","rows","rowCount","getRowCount","prevRowIndex","prevColumnIndex","prevRow","prevCell","lastColumnIndex","getLastEnabledColumnIndex","nextRowIndex","nextColumnIndex","nextRow","nextCell","isGridCollection","access","node","indexPath","getChildren","ancestorIndexPaths","indexPaths","sortedPaths","sortIndexPaths","seen","Set","add","compareIndexPaths","found","visit","onEnter","child","predicate","findIndexPath","reduce","initialResult","nextResult","flatMap","transform","insertOperation","nodes","type","removeOperation","indexes","replaceOperation","splitIndexPath","getInsertionOperations","operations","parentIndexPath","parentKey","operation","removeIndexes","insertIndex","insertNodes","getRemovalOperations","indexesToRemove","getReplaceOperations","mutate","node2","children","create","updatedChildren","adjustedIndex","removedIndex","splice","array","start","deleteCount","childrenMap","onLeave","keyIndexPath","transformed","parentChildren","insert2","Error","replace","remove","move2","_ancestorIndexPaths","nodesToInsert","stack","getIndexPath","reuseIndexPath","wrapper","enterResult","currentIndex","leaveResult","pop","TreeCollection","rootNode","nodeToChildren","fallback2","nodeToValue","isNodeDisabled","findNode","stringifyNode","nodeToString","firstChild","getNodeChildren","getNodeDisabled","opts","lastChild","nodeValue","getNodeValue","skip","acc","valuePath","currentPath","unshift","valueIndexPath","nextNode","isRootNode","previousNode","parentNode","valueOrIndexPath","getParentIndexPath","rest","getParentNode","siblings","sibling","getValue","depth","isSameDepth","_create","_replace","_remove","_insert","nextIndex2","fromIndexPaths","toIndexPath","_move","getValues","flattenedToTree","assign","filePathToTree","paths","path","parts","split","currentNode","part","childNode","Selection","_Selection","clone","sync","selectionMode","deselectable","collection","anchorValue","targetValue","replaceSelection","selection","lastSelected","getValueRange","delete","canSelect","isSelected","clear","forceToggle","toggleSelection"],"sources":["C:/Users/tuanl/weekly-todo-frontend/node_modules/@chakra-ui/react/node_modules/@zag-js/collection/dist/index.mjs"],"sourcesContent":["import { compact, isEqual, chunk, prevIndex, nextIndex, isObject, hasProp } from '@zag-js/utils';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar fallback = {\n  itemToValue(item) {\n    if (typeof item === \"string\") return item;\n    if (isObject(item) && hasProp(item, \"value\")) return item.value;\n    return \"\";\n  },\n  itemToString(item) {\n    if (typeof item === \"string\") return item;\n    if (isObject(item) && hasProp(item, \"label\")) return item.label;\n    return fallback.itemToValue(item);\n  },\n  isItemDisabled(item) {\n    if (isObject(item) && hasProp(item, \"disabled\")) return !!item.disabled;\n    return false;\n  }\n};\nvar ListCollection = class _ListCollection {\n  constructor(options) {\n    this.options = options;\n    /**\n     * The items in the collection\n     */\n    __publicField(this, \"items\");\n    /**\n     * Copy the collection\n     */\n    __publicField(this, \"copy\", (items) => {\n      return new _ListCollection({ ...this.options, items: items ?? [...this.items] });\n    });\n    /**\n     * Check if the collection is equal to another collection\n     */\n    __publicField(this, \"isEqual\", (other) => {\n      return isEqual(this.items, other.items);\n    });\n    /**\n     * Function to update the collection items\n     */\n    __publicField(this, \"setItems\", (items) => {\n      return this.copy(items);\n    });\n    /**\n     * Returns all the values in the collection\n     */\n    __publicField(this, \"getValues\", (items = this.items) => {\n      return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);\n    });\n    /**\n     * Get the item based on its value\n     */\n    __publicField(this, \"find\", (value) => {\n      if (value == null) return null;\n      const index = this.indexOf(value);\n      return index != null ? this.at(index) : null;\n    });\n    /**\n     * Get the items based on its values\n     */\n    __publicField(this, \"findMany\", (values) => {\n      return Array.from(values).map((value) => this.find(value)).filter((item) => item != null);\n    });\n    /**\n     * Get the item based on its index\n     */\n    __publicField(this, \"at\", (index) => {\n      if (!this.options.groupBy && !this.options.groupSort) {\n        return this.items[index] ?? null;\n      }\n      let idx = 0;\n      const groups = this.group();\n      for (const [, items] of groups) {\n        for (const item of items) {\n          if (idx === index) return item;\n          idx++;\n        }\n      }\n      return null;\n    });\n    __publicField(this, \"sortFn\", (valueA, valueB) => {\n      const indexA = this.indexOf(valueA);\n      const indexB = this.indexOf(valueB);\n      return (indexA ?? 0) - (indexB ?? 0);\n    });\n    /**\n     * Sort the values based on their index\n     */\n    __publicField(this, \"sort\", (values) => {\n      return [...values].sort(this.sortFn.bind(this));\n    });\n    /**\n     * Convert an item to a value\n     */\n    __publicField(this, \"getItemValue\", (item) => {\n      if (item == null) return null;\n      return this.options.itemToValue?.(item) ?? fallback.itemToValue(item);\n    });\n    /**\n     * Whether an item is disabled\n     */\n    __publicField(this, \"getItemDisabled\", (item) => {\n      if (item == null) return false;\n      return this.options.isItemDisabled?.(item) ?? fallback.isItemDisabled(item);\n    });\n    /**\n     * Convert an item to a string\n     */\n    __publicField(this, \"stringifyItem\", (item) => {\n      if (item == null) return null;\n      return this.options.itemToString?.(item) ?? fallback.itemToString(item);\n    });\n    /**\n     * Convert a value to a string\n     */\n    __publicField(this, \"stringify\", (value) => {\n      if (value == null) return null;\n      return this.stringifyItem(this.find(value));\n    });\n    /**\n     * Convert an array of items to a string\n     */\n    __publicField(this, \"stringifyItems\", (items, separator = \", \") => {\n      return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);\n    });\n    /**\n     * Convert an array of items to a string\n     */\n    __publicField(this, \"stringifyMany\", (value, separator) => {\n      return this.stringifyItems(this.findMany(value), separator);\n    });\n    /**\n     * Whether the collection has a value\n     */\n    __publicField(this, \"has\", (value) => {\n      return this.indexOf(value) !== -1;\n    });\n    /**\n     * Whether the collection has an item\n     */\n    __publicField(this, \"hasItem\", (item) => {\n      if (item == null) return false;\n      return this.has(this.getItemValue(item));\n    });\n    /**\n     * Group items by the groupBy function provided in options\n     * Returns an array of [groupKey, items] tuples\n     */\n    __publicField(this, \"group\", () => {\n      const { groupBy, groupSort } = this.options;\n      if (!groupBy) return [[\"\", [...this.items]]];\n      const groups = /* @__PURE__ */ new Map();\n      this.items.forEach((item, index) => {\n        const groupKey = groupBy(item, index);\n        if (!groups.has(groupKey)) {\n          groups.set(groupKey, []);\n        }\n        groups.get(groupKey).push(item);\n      });\n      let entries = Array.from(groups.entries());\n      if (groupSort) {\n        entries.sort(([a], [b]) => {\n          if (typeof groupSort === \"function\") return groupSort(a, b);\n          if (Array.isArray(groupSort)) {\n            const indexA = groupSort.indexOf(a);\n            const indexB = groupSort.indexOf(b);\n            if (indexA === -1) return 1;\n            if (indexB === -1) return -1;\n            return indexA - indexB;\n          }\n          if (groupSort === \"asc\") return a.localeCompare(b);\n          if (groupSort === \"desc\") return b.localeCompare(a);\n          return 0;\n        });\n      }\n      return entries;\n    });\n    /**\n     * Returns the next value in the collection\n     */\n    __publicField(this, \"getNextValue\", (value, step = 1, clamp = false) => {\n      let index = this.indexOf(value);\n      if (index === -1) return null;\n      index = clamp ? Math.min(index + step, this.size - 1) : index + step;\n      while (index <= this.size && this.getItemDisabled(this.at(index))) index++;\n      return this.getItemValue(this.at(index));\n    });\n    /**\n     * Returns the previous value in the collection\n     */\n    __publicField(this, \"getPreviousValue\", (value, step = 1, clamp = false) => {\n      let index = this.indexOf(value);\n      if (index === -1) return null;\n      index = clamp ? Math.max(index - step, 0) : index - step;\n      while (index >= 0 && this.getItemDisabled(this.at(index))) index--;\n      return this.getItemValue(this.at(index));\n    });\n    /**\n     * Get the index of an item based on its key\n     */\n    __publicField(this, \"indexOf\", (value) => {\n      if (value == null) return -1;\n      if (!this.options.groupBy && !this.options.groupSort) {\n        return this.items.findIndex((item) => this.getItemValue(item) === value);\n      }\n      let idx = 0;\n      const groups = this.group();\n      for (const [, items] of groups) {\n        for (const item of items) {\n          if (this.getItemValue(item) === value) return idx;\n          idx++;\n        }\n      }\n      return -1;\n    });\n    __publicField(this, \"getByText\", (text, current) => {\n      let items = current != null ? wrap(this.items, this.indexOf(current)) : this.items;\n      const isSingleKey = text.length === 1;\n      if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);\n      return items.find((item) => match(this.stringifyItem(item), text));\n    });\n    /**\n     * Search for a value based on a query\n     */\n    __publicField(this, \"search\", (queryString, options) => {\n      const { state, currentValue, timeout = 350 } = options;\n      const search = state.keysSoFar + queryString;\n      const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n      const query = isRepeated ? search[0] : search;\n      const item = this.getByText(query, currentValue);\n      const value = this.getItemValue(item);\n      function cleanup() {\n        clearTimeout(state.timer);\n        state.timer = -1;\n      }\n      function update(value2) {\n        state.keysSoFar = value2;\n        cleanup();\n        if (value2 !== \"\") {\n          state.timer = +setTimeout(() => {\n            update(\"\");\n            cleanup();\n          }, timeout);\n        }\n      }\n      update(search);\n      return value;\n    });\n    /**\n     * Update an item in the collection\n     */\n    __publicField(this, \"update\", (value, item) => {\n      let index = this.items.findIndex((item2) => this.getItemValue(item2) === value);\n      if (index === -1) return this;\n      return this.copy([...this.items.slice(0, index), item, ...this.items.slice(index + 1)]);\n    });\n    /**\n     * Insert items at a specific index\n     */\n    __publicField(this, \"insert\", (index, ...items) => {\n      return this.copy(insert(this.items, index, ...items));\n    });\n    /**\n     * Insert items before a specific value\n     */\n    __publicField(this, \"insertBefore\", (value, ...items) => {\n      let toIndex = this.indexOf(value);\n      if (toIndex === -1) {\n        if (this.items.length === 0) toIndex = 0;\n        else return this;\n      }\n      return this.copy(insert(this.items, toIndex, ...items));\n    });\n    /**\n     * Insert items after a specific value\n     */\n    __publicField(this, \"insertAfter\", (value, ...items) => {\n      let toIndex = this.indexOf(value);\n      if (toIndex === -1) {\n        if (this.items.length === 0) toIndex = 0;\n        else return this;\n      }\n      return this.copy(insert(this.items, toIndex + 1, ...items));\n    });\n    /**\n     * Prepend items to the collection\n     */\n    __publicField(this, \"prepend\", (...items) => {\n      return this.copy(insert(this.items, 0, ...items));\n    });\n    /**\n     * Append items to the collection\n     */\n    __publicField(this, \"append\", (...items) => {\n      return this.copy(insert(this.items, this.items.length, ...items));\n    });\n    /**\n     * Filter the collection\n     */\n    __publicField(this, \"filter\", (fn) => {\n      const filteredItems = this.items.filter((item, index) => fn(this.stringifyItem(item), index));\n      return this.copy(filteredItems);\n    });\n    /**\n     * Remove items from the collection\n     */\n    __publicField(this, \"remove\", (...itemsOrValues) => {\n      const values = itemsOrValues.map(\n        (itemOrValue) => typeof itemOrValue === \"string\" ? itemOrValue : this.getItemValue(itemOrValue)\n      );\n      return this.copy(\n        this.items.filter((item) => {\n          const value = this.getItemValue(item);\n          if (value == null) return false;\n          return !values.includes(value);\n        })\n      );\n    });\n    /**\n     * Move an item to a specific index\n     */\n    __publicField(this, \"move\", (value, toIndex) => {\n      const fromIndex = this.indexOf(value);\n      if (fromIndex === -1) return this;\n      return this.copy(move(this.items, [fromIndex], toIndex));\n    });\n    /**\n     * Move items before a specific value\n     */\n    __publicField(this, \"moveBefore\", (value, ...values) => {\n      let toIndex = this.items.findIndex((item) => this.getItemValue(item) === value);\n      if (toIndex === -1) return this;\n      let indices = values.map((value2) => this.items.findIndex((item) => this.getItemValue(item) === value2)).sort((a, b) => a - b);\n      return this.copy(move(this.items, indices, toIndex));\n    });\n    /**\n     * Move items after a specific value\n     */\n    __publicField(this, \"moveAfter\", (value, ...values) => {\n      let toIndex = this.items.findIndex((item) => this.getItemValue(item) === value);\n      if (toIndex === -1) return this;\n      let indices = values.map((value2) => this.items.findIndex((item) => this.getItemValue(item) === value2)).sort((a, b) => a - b);\n      return this.copy(move(this.items, indices, toIndex + 1));\n    });\n    /**\n     * Reorder items\n     */\n    __publicField(this, \"reorder\", (fromIndex, toIndex) => {\n      return this.copy(move(this.items, [fromIndex], toIndex));\n    });\n    /**\n     * Compare two values\n     */\n    __publicField(this, \"compareValue\", (a, b) => {\n      const indexA = this.indexOf(a);\n      const indexB = this.indexOf(b);\n      if (indexA < indexB) return -1;\n      if (indexA > indexB) return 1;\n      return 0;\n    });\n    /**\n     * Get the range of values between two values\n     */\n    __publicField(this, \"range\", (from, to) => {\n      let keys = [];\n      let key = from;\n      while (key != null) {\n        let item = this.find(key);\n        if (item) keys.push(key);\n        if (key === to) return keys;\n        key = this.getNextValue(key);\n      }\n      return [];\n    });\n    /**\n     * Get the range of values between two values\n     */\n    __publicField(this, \"getValueRange\", (from, to) => {\n      if (from && to) {\n        if (this.compareValue(from, to) <= 0) {\n          return this.range(from, to);\n        }\n        return this.range(to, from);\n      }\n      return [];\n    });\n    /**\n     * Convert the collection to a string\n     */\n    __publicField(this, \"toString\", () => {\n      let result = \"\";\n      for (const item of this.items) {\n        const value = this.getItemValue(item);\n        const label = this.stringifyItem(item);\n        const disabled = this.getItemDisabled(item);\n        const itemString = [value, label, disabled].filter(Boolean).join(\":\");\n        result += itemString + \",\";\n      }\n      return result;\n    });\n    /**\n     * Convert the collection to a JSON object\n     */\n    __publicField(this, \"toJSON\", () => {\n      return {\n        size: this.size,\n        first: this.firstValue,\n        last: this.lastValue\n      };\n    });\n    this.items = [...options.items];\n  }\n  /**\n   * Returns the number of items in the collection\n   */\n  get size() {\n    return this.items.length;\n  }\n  /**\n   * Returns the first value in the collection\n   */\n  get firstValue() {\n    let index = 0;\n    while (this.getItemDisabled(this.at(index))) index++;\n    return this.getItemValue(this.at(index));\n  }\n  /**\n   * Returns the last value in the collection\n   */\n  get lastValue() {\n    let index = this.size - 1;\n    while (this.getItemDisabled(this.at(index))) index--;\n    return this.getItemValue(this.at(index));\n  }\n  *[Symbol.iterator]() {\n    yield* this.items;\n  }\n};\nvar match = (label, query) => {\n  return !!label?.toLowerCase().startsWith(query.toLowerCase());\n};\nvar wrap = (v, idx) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);\n};\nfunction isListCollection(v) {\n  return v instanceof ListCollection;\n}\nfunction insert(items, index, ...values) {\n  return [...items.slice(0, index), ...values, ...items.slice(index)];\n}\nfunction move(items, indices, toIndex) {\n  indices = [...indices].sort((a, b) => a - b);\n  const itemsToMove = indices.map((i) => items[i]);\n  for (let i = indices.length - 1; i >= 0; i--) {\n    items = [...items.slice(0, indices[i]), ...items.slice(indices[i] + 1)];\n  }\n  toIndex = Math.max(0, toIndex - indices.filter((i) => i < toIndex).length);\n  return [...items.slice(0, toIndex), ...itemsToMove, ...items.slice(toIndex)];\n}\n\n// src/grid-collection.ts\nvar GridCollection = class extends ListCollection {\n  constructor(options) {\n    const { columnCount } = options;\n    super(options);\n    __publicField(this, \"columnCount\");\n    /**\n     * Returns the row data in the grid\n     */\n    __publicField(this, \"getRows\", () => {\n      return chunk([...this.items], this.columnCount);\n    });\n    /**\n     * Returns the number of rows in the grid\n     */\n    __publicField(this, \"getRowCount\", () => {\n      return this.getRows().length;\n    });\n    /**\n     * Returns the index of the specified row and column in the grid\n     */\n    __publicField(this, \"getCellIndex\", (row, column) => {\n      return row * this.columnCount + column;\n    });\n    /**\n     * Returns the item at the specified row and column in the grid\n     */\n    __publicField(this, \"getCell\", (row, column) => {\n      return this.at(this.getCellIndex(row, column));\n    });\n    /**\n     * Returns the row and column index for a given value\n     */\n    __publicField(this, \"getValueCell\", (value) => {\n      const index = this.indexOf(value);\n      if (index === -1) return null;\n      const row = Math.floor(index / this.columnCount);\n      const column = index % this.columnCount;\n      return { row, column };\n    });\n    /**\n     * Returns the value of the last enabled column in a row\n     */\n    __publicField(this, \"getLastEnabledColumnIndex\", (row) => {\n      for (let col = this.columnCount - 1; col >= 0; col--) {\n        const cell = this.getCell(row, col);\n        if (cell && !this.getItemDisabled(cell)) {\n          return col;\n        }\n      }\n      return null;\n    });\n    /**\n     * Returns the index of the first enabled column in a row\n     */\n    __publicField(this, \"getFirstEnabledColumnIndex\", (row) => {\n      for (let col = 0; col < this.columnCount; col++) {\n        const cell = this.getCell(row, col);\n        if (cell && !this.getItemDisabled(cell)) {\n          return col;\n        }\n      }\n      return null;\n    });\n    /**\n     * Returns the value of the previous row in the grid, based on the current value\n     */\n    __publicField(this, \"getPreviousRowValue\", (value, loop = false) => {\n      const currentCell = this.getValueCell(value);\n      if (currentCell === null) return null;\n      const rows = this.getRows();\n      const rowCount = this.getRowCount();\n      let prevRowIndex = currentCell.row;\n      let prevColumnIndex = currentCell.column;\n      for (let i = 1; i <= rowCount; i++) {\n        prevRowIndex = prevIndex(rows, prevRowIndex, { loop });\n        const prevRow = rows[prevRowIndex];\n        if (!prevRow) continue;\n        const prevCell = prevRow[prevColumnIndex];\n        if (!prevCell) {\n          const lastColumnIndex = this.getLastEnabledColumnIndex(prevRowIndex);\n          if (lastColumnIndex != null) {\n            prevColumnIndex = lastColumnIndex;\n          }\n        }\n        const cell = this.getCell(prevRowIndex, prevColumnIndex);\n        if (!this.getItemDisabled(cell)) {\n          return this.getItemValue(cell);\n        }\n      }\n      return this.firstValue;\n    });\n    /**\n     * Returns the value of the next row in the grid, based on the current value\n     */\n    __publicField(this, \"getNextRowValue\", (value, loop = false) => {\n      const currentCell = this.getValueCell(value);\n      if (currentCell === null) return null;\n      const rows = this.getRows();\n      const rowCount = this.getRowCount();\n      let nextRowIndex = currentCell.row;\n      let nextColumnIndex = currentCell.column;\n      for (let i = 1; i <= rowCount; i++) {\n        nextRowIndex = nextIndex(rows, nextRowIndex, { loop });\n        const nextRow = rows[nextRowIndex];\n        if (!nextRow) continue;\n        const nextCell = nextRow[nextColumnIndex];\n        if (!nextCell) {\n          const lastColumnIndex = this.getLastEnabledColumnIndex(nextRowIndex);\n          if (lastColumnIndex != null) {\n            nextColumnIndex = lastColumnIndex;\n          }\n        }\n        const cell = this.getCell(nextRowIndex, nextColumnIndex);\n        if (!this.getItemDisabled(cell)) {\n          return this.getItemValue(cell);\n        }\n      }\n      return this.lastValue;\n    });\n    this.columnCount = columnCount;\n  }\n};\nfunction isGridCollection(v) {\n  return v instanceof GridCollection;\n}\n\n// src/tree-visit.ts\nfunction access(node, indexPath, options) {\n  for (let i = 0; i < indexPath.length; i++) node = options.getChildren(node, indexPath.slice(i + 1))[indexPath[i]];\n  return node;\n}\nfunction ancestorIndexPaths(indexPaths) {\n  const sortedPaths = sortIndexPaths(indexPaths);\n  const result = [];\n  const seen = /* @__PURE__ */ new Set();\n  for (const indexPath of sortedPaths) {\n    const key = indexPath.join();\n    if (!seen.has(key)) {\n      seen.add(key);\n      result.push(indexPath);\n    }\n  }\n  return result;\n}\nfunction compareIndexPaths(a, b) {\n  for (let i = 0; i < Math.min(a.length, b.length); i++) {\n    if (a[i] < b[i]) return -1;\n    if (a[i] > b[i]) return 1;\n  }\n  return a.length - b.length;\n}\nfunction sortIndexPaths(indexPaths) {\n  return indexPaths.sort(compareIndexPaths);\n}\nfunction find(node, options) {\n  let found;\n  visit(node, {\n    ...options,\n    onEnter: (child, indexPath) => {\n      if (options.predicate(child, indexPath)) {\n        found = child;\n        return \"stop\";\n      }\n    }\n  });\n  return found;\n}\nfunction findIndexPath(node, options) {\n  let found;\n  visit(node, {\n    onEnter: (child, indexPath) => {\n      if (options.predicate(child, indexPath)) {\n        found = [...indexPath];\n        return \"stop\";\n      }\n    },\n    getChildren: options.getChildren\n  });\n  return found;\n}\nfunction reduce(node, options) {\n  let result = options.initialResult;\n  visit(node, {\n    ...options,\n    onEnter: (child, indexPath) => {\n      result = options.nextResult(result, child, indexPath);\n    }\n  });\n  return result;\n}\nfunction flatMap(node, options) {\n  return reduce(node, {\n    ...options,\n    initialResult: [],\n    nextResult: (result, child, indexPath) => {\n      result.push(...options.transform(child, indexPath));\n      return result;\n    }\n  });\n}\nfunction insertOperation(index, nodes) {\n  return { type: \"insert\", index, nodes };\n}\nfunction removeOperation(indexes) {\n  return { type: \"remove\", indexes };\n}\nfunction replaceOperation() {\n  return { type: \"replace\" };\n}\nfunction splitIndexPath(indexPath) {\n  return [indexPath.slice(0, -1), indexPath[indexPath.length - 1]];\n}\nfunction getInsertionOperations(indexPath, nodes, operations = /* @__PURE__ */ new Map()) {\n  const [parentIndexPath, index] = splitIndexPath(indexPath);\n  for (let i = parentIndexPath.length - 1; i >= 0; i--) {\n    const parentKey = parentIndexPath.slice(0, i).join();\n    switch (operations.get(parentKey)?.type) {\n      case \"remove\":\n        continue;\n    }\n    operations.set(parentKey, replaceOperation());\n  }\n  const operation = operations.get(parentIndexPath.join());\n  switch (operation?.type) {\n    case \"remove\":\n      operations.set(parentIndexPath.join(), {\n        type: \"removeThenInsert\",\n        removeIndexes: operation.indexes,\n        insertIndex: index,\n        insertNodes: nodes\n      });\n      break;\n    default:\n      operations.set(parentIndexPath.join(), insertOperation(index, nodes));\n  }\n  return operations;\n}\nfunction getRemovalOperations(indexPaths) {\n  const operations = /* @__PURE__ */ new Map();\n  const indexesToRemove = /* @__PURE__ */ new Map();\n  for (const indexPath of indexPaths) {\n    const parentKey = indexPath.slice(0, -1).join();\n    const value = indexesToRemove.get(parentKey) ?? [];\n    value.push(indexPath[indexPath.length - 1]);\n    indexesToRemove.set(\n      parentKey,\n      value.sort((a, b) => a - b)\n    );\n  }\n  for (const indexPath of indexPaths) {\n    for (let i = indexPath.length - 2; i >= 0; i--) {\n      const parentKey = indexPath.slice(0, i).join();\n      if (!operations.has(parentKey)) {\n        operations.set(parentKey, replaceOperation());\n      }\n    }\n  }\n  for (const [parentKey, indexes] of indexesToRemove) {\n    operations.set(parentKey, removeOperation(indexes));\n  }\n  return operations;\n}\nfunction getReplaceOperations(indexPath, node) {\n  const operations = /* @__PURE__ */ new Map();\n  const [parentIndexPath, index] = splitIndexPath(indexPath);\n  for (let i = parentIndexPath.length - 1; i >= 0; i--) {\n    const parentKey = parentIndexPath.slice(0, i).join();\n    operations.set(parentKey, replaceOperation());\n  }\n  operations.set(parentIndexPath.join(), {\n    type: \"removeThenInsert\",\n    removeIndexes: [index],\n    insertIndex: index,\n    insertNodes: [node]\n  });\n  return operations;\n}\nfunction mutate(node, operations, options) {\n  return map(node, {\n    ...options,\n    getChildren: (node2, indexPath) => {\n      const key = indexPath.join();\n      const operation = operations.get(key);\n      switch (operation?.type) {\n        case \"replace\":\n        case \"remove\":\n        case \"removeThenInsert\":\n        case \"insert\":\n          return options.getChildren(node2, indexPath);\n        default:\n          return [];\n      }\n    },\n    transform: (node2, children, indexPath) => {\n      const key = indexPath.join();\n      const operation = operations.get(key);\n      switch (operation?.type) {\n        case \"remove\":\n          return options.create(\n            node2,\n            children.filter((_, index) => !operation.indexes.includes(index)),\n            indexPath\n          );\n        case \"removeThenInsert\":\n          const updatedChildren = children.filter((_, index) => !operation.removeIndexes.includes(index));\n          const adjustedIndex = operation.removeIndexes.reduce(\n            (index, removedIndex) => removedIndex < index ? index - 1 : index,\n            operation.insertIndex\n          );\n          return options.create(node2, splice(updatedChildren, adjustedIndex, 0, ...operation.insertNodes), indexPath);\n        case \"insert\":\n          return options.create(node2, splice(children, operation.index, 0, ...operation.nodes), indexPath);\n        case \"replace\":\n          return options.create(node2, children, indexPath);\n        default:\n          return node2;\n      }\n    }\n  });\n}\nfunction splice(array, start, deleteCount, ...items) {\n  return [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)];\n}\nfunction map(node, options) {\n  const childrenMap = {};\n  visit(node, {\n    ...options,\n    onLeave: (child, indexPath) => {\n      const keyIndexPath = [0, ...indexPath];\n      const key = keyIndexPath.join();\n      const transformed = options.transform(child, childrenMap[key] ?? [], indexPath);\n      const parentKey = keyIndexPath.slice(0, -1).join();\n      const parentChildren = childrenMap[parentKey] ?? [];\n      parentChildren.push(transformed);\n      childrenMap[parentKey] = parentChildren;\n    }\n  });\n  return childrenMap[\"\"][0];\n}\nfunction insert2(node, options) {\n  const { nodes, at } = options;\n  if (at.length === 0) throw new Error(`Can't insert nodes at the root`);\n  const state = getInsertionOperations(at, nodes);\n  return mutate(node, state, options);\n}\nfunction replace(node, options) {\n  if (options.at.length === 0) return options.node;\n  const operations = getReplaceOperations(options.at, options.node);\n  return mutate(node, operations, options);\n}\nfunction remove(node, options) {\n  if (options.indexPaths.length === 0) return node;\n  for (const indexPath of options.indexPaths) {\n    if (indexPath.length === 0) throw new Error(`Can't remove the root node`);\n  }\n  const operations = getRemovalOperations(options.indexPaths);\n  return mutate(node, operations, options);\n}\nfunction move2(node, options) {\n  if (options.indexPaths.length === 0) return node;\n  for (const indexPath of options.indexPaths) {\n    if (indexPath.length === 0) throw new Error(`Can't move the root node`);\n  }\n  if (options.to.length === 0) throw new Error(`Can't move nodes to the root`);\n  const _ancestorIndexPaths = ancestorIndexPaths(options.indexPaths);\n  const nodesToInsert = _ancestorIndexPaths.map((indexPath) => access(node, indexPath, options));\n  const operations = getInsertionOperations(options.to, nodesToInsert, getRemovalOperations(_ancestorIndexPaths));\n  return mutate(node, operations, options);\n}\nfunction visit(node, options) {\n  const { onEnter, onLeave, getChildren } = options;\n  let indexPath = [];\n  let stack = [{ node }];\n  const getIndexPath = options.reuseIndexPath ? () => indexPath : () => indexPath.slice();\n  while (stack.length > 0) {\n    let wrapper = stack[stack.length - 1];\n    if (wrapper.state === void 0) {\n      const enterResult = onEnter?.(wrapper.node, getIndexPath());\n      if (enterResult === \"stop\") return;\n      wrapper.state = enterResult === \"skip\" ? -1 : 0;\n    }\n    const children = wrapper.children || getChildren(wrapper.node, getIndexPath());\n    wrapper.children || (wrapper.children = children);\n    if (wrapper.state !== -1) {\n      if (wrapper.state < children.length) {\n        let currentIndex = wrapper.state;\n        indexPath.push(currentIndex);\n        stack.push({ node: children[currentIndex] });\n        wrapper.state = currentIndex + 1;\n        continue;\n      }\n      const leaveResult = onLeave?.(wrapper.node, getIndexPath());\n      if (leaveResult === \"stop\") return;\n    }\n    indexPath.pop();\n    stack.pop();\n  }\n}\n\n// src/tree-collection.ts\nvar TreeCollection = class {\n  constructor(options) {\n    this.options = options;\n    __publicField(this, \"rootNode\");\n    __publicField(this, \"isEqual\", (other) => {\n      return isEqual(this.rootNode, other.rootNode);\n    });\n    __publicField(this, \"getNodeChildren\", (node) => {\n      return this.options.nodeToChildren?.(node) ?? fallback2.nodeToChildren(node) ?? [];\n    });\n    __publicField(this, \"getNodeValue\", (node) => {\n      return this.options.nodeToValue?.(node) ?? fallback2.nodeToValue(node);\n    });\n    __publicField(this, \"getNodeDisabled\", (node) => {\n      return this.options.isNodeDisabled?.(node) ?? fallback2.isNodeDisabled(node);\n    });\n    __publicField(this, \"stringify\", (value) => {\n      const node = this.findNode(value);\n      if (!node) return null;\n      return this.stringifyNode(node);\n    });\n    __publicField(this, \"stringifyNode\", (node) => {\n      return this.options.nodeToString?.(node) ?? fallback2.nodeToString(node);\n    });\n    __publicField(this, \"getFirstNode\", (rootNode = this.rootNode) => {\n      let firstChild;\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (!firstChild && indexPath.length > 0 && !this.getNodeDisabled(node)) {\n            firstChild = node;\n            return \"stop\";\n          }\n        }\n      });\n      return firstChild;\n    });\n    __publicField(this, \"getLastNode\", (rootNode = this.rootNode, opts = {}) => {\n      let lastChild;\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({ value: nodeValue, node, indexPath })) return \"skip\";\n          if (indexPath.length > 1) return \"skip\";\n          if (!this.getNodeDisabled(node)) {\n            lastChild = node;\n          }\n        }\n      });\n      return lastChild;\n    });\n    __publicField(this, \"at\", (indexPath) => {\n      return access(this.rootNode, indexPath, {\n        getChildren: this.getNodeChildren\n      });\n    });\n    __publicField(this, \"findNode\", (value, rootNode = this.rootNode) => {\n      return find(rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: (node) => this.getNodeValue(node) === value\n      });\n    });\n    __publicField(this, \"sort\", (values) => {\n      return values.reduce(\n        (acc, value) => {\n          const indexPath = this.getIndexPath(value);\n          if (indexPath != null) acc.push({ value, indexPath });\n          return acc;\n        },\n        []\n      ).sort((a, b) => compareIndexPaths(a.indexPath, b.indexPath)).map(({ value }) => value);\n    });\n    __publicField(this, \"getIndexPath\", (value) => {\n      return findIndexPath(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: (node) => this.getNodeValue(node) === value\n      });\n    });\n    __publicField(this, \"getValue\", (indexPath) => {\n      const node = this.at(indexPath);\n      return node ? this.getNodeValue(node) : void 0;\n    });\n    __publicField(this, \"getValuePath\", (indexPath) => {\n      if (!indexPath) return [];\n      const valuePath = [];\n      let currentPath = [...indexPath];\n      while (currentPath.length > 0) {\n        const node = this.at(currentPath);\n        if (node) valuePath.unshift(this.getNodeValue(node));\n        currentPath.pop();\n      }\n      return valuePath;\n    });\n    __publicField(this, \"getDepth\", (value) => {\n      const indexPath = findIndexPath(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: (node) => this.getNodeValue(node) === value\n      });\n      return indexPath?.length ?? 0;\n    });\n    __publicField(this, \"isRootNode\", (node) => {\n      return this.getNodeValue(node) === this.getNodeValue(this.rootNode);\n    });\n    __publicField(this, \"contains\", (parentIndexPath, valueIndexPath) => {\n      if (!parentIndexPath || !valueIndexPath) return false;\n      return valueIndexPath.slice(0, parentIndexPath.length).every((_, i) => parentIndexPath[i] === valueIndexPath[i]);\n    });\n    __publicField(this, \"getNextNode\", (value, opts = {}) => {\n      let found = false;\n      let nextNode;\n      visit(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({ value: nodeValue, node, indexPath })) {\n            if (nodeValue === value) {\n              found = true;\n            }\n            return \"skip\";\n          }\n          if (found && !this.getNodeDisabled(node)) {\n            nextNode = node;\n            return \"stop\";\n          }\n          if (nodeValue === value) {\n            found = true;\n          }\n        }\n      });\n      return nextNode;\n    });\n    __publicField(this, \"getPreviousNode\", (value, opts = {}) => {\n      let previousNode;\n      let found = false;\n      visit(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({ value: nodeValue, node, indexPath })) {\n            return \"skip\";\n          }\n          if (nodeValue === value) {\n            found = true;\n            return \"stop\";\n          }\n          if (!this.getNodeDisabled(node)) {\n            previousNode = node;\n          }\n        }\n      });\n      return found ? previousNode : void 0;\n    });\n    __publicField(this, \"getParentNodes\", (values) => {\n      const result = [];\n      let indexPath = this.getIndexPath(values);\n      while (indexPath && indexPath.length > 0) {\n        indexPath.pop();\n        const parentNode = this.at(indexPath);\n        if (parentNode && !this.isRootNode(parentNode)) {\n          result.unshift(parentNode);\n        }\n      }\n      return result;\n    });\n    __publicField(this, \"getParentIndexPath\", (indexPath) => {\n      return indexPath.slice(0, -1);\n    });\n    __publicField(this, \"getParentNode\", (valueOrIndexPath) => {\n      const indexPath = typeof valueOrIndexPath === \"string\" ? this.getIndexPath(valueOrIndexPath) : valueOrIndexPath;\n      return indexPath ? this.at(this.getParentIndexPath(indexPath)) : void 0;\n    });\n    __publicField(this, \"visit\", (opts) => {\n      const { skip, ...rest } = opts;\n      visit(this.rootNode, {\n        ...rest,\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          if (skip?.({ value: this.getNodeValue(node), node, indexPath })) return \"skip\";\n          return rest.onEnter?.(node, indexPath);\n        }\n      });\n    });\n    __publicField(this, \"getPreviousSibling\", (indexPath) => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const siblings = this.getNodeChildren(parentNode);\n      let idx = siblings.findIndex((sibling) => this.getValue(indexPath) === this.getNodeValue(sibling));\n      while (--idx >= 0) {\n        const sibling = siblings[idx];\n        if (!this.getNodeDisabled(sibling)) return sibling;\n      }\n      return;\n    });\n    __publicField(this, \"getNextSibling\", (indexPath) => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const siblings = this.getNodeChildren(parentNode);\n      let idx = siblings.findIndex((sibling) => this.getValue(indexPath) === this.getNodeValue(sibling));\n      while (++idx < siblings.length) {\n        const sibling = siblings[idx];\n        if (!this.getNodeDisabled(sibling)) return sibling;\n      }\n      return;\n    });\n    __publicField(this, \"getSiblingNodes\", (indexPath) => {\n      const parentNode = this.getParentNode(indexPath);\n      return parentNode ? this.getNodeChildren(parentNode) : [];\n    });\n    __publicField(this, \"getValues\", (rootNode = this.rootNode) => {\n      const values = flatMap(rootNode, {\n        getChildren: this.getNodeChildren,\n        transform: (node) => [this.getNodeValue(node)]\n      });\n      return values.slice(1);\n    });\n    __publicField(this, \"isSameDepth\", (indexPath, depth) => {\n      if (depth == null) return true;\n      return indexPath.length === depth;\n    });\n    __publicField(this, \"isBranchNode\", (node) => {\n      return this.getNodeChildren(node).length > 0;\n    });\n    __publicField(this, \"getBranchValues\", (rootNode = this.rootNode, opts = {}) => {\n      let values = [];\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({ value: nodeValue, node, indexPath })) return \"skip\";\n          if (this.getNodeChildren(node).length > 0 && this.isSameDepth(indexPath, opts.depth)) {\n            values.push(this.getNodeValue(node));\n          }\n        }\n      });\n      return values.slice(1);\n    });\n    __publicField(this, \"flatten\", (rootNode = this.rootNode) => {\n      const nodes = flatMap(rootNode, {\n        getChildren: this.getNodeChildren,\n        transform: (node, indexPath) => {\n          const children = this.getNodeChildren(node).map((child) => this.getNodeValue(child));\n          return [\n            compact({\n              label: this.stringifyNode(node),\n              value: this.getNodeValue(node),\n              indexPath,\n              children: children.length > 0 ? children : void 0\n            })\n          ];\n        }\n      });\n      return nodes.slice(1);\n    });\n    __publicField(this, \"_create\", (node, children) => {\n      return compact({ ...node, children });\n    });\n    __publicField(this, \"_insert\", (rootNode, indexPath, nodes) => {\n      return insert2(rootNode, { at: indexPath, nodes, getChildren: this.getNodeChildren, create: this._create });\n    });\n    __publicField(this, \"_replace\", (rootNode, indexPath, node) => {\n      return replace(rootNode, { at: indexPath, node, getChildren: this.getNodeChildren, create: this._create });\n    });\n    __publicField(this, \"_move\", (rootNode, indexPaths, to) => {\n      return move2(rootNode, { indexPaths, to, getChildren: this.getNodeChildren, create: this._create });\n    });\n    __publicField(this, \"_remove\", (rootNode, indexPaths) => {\n      return remove(rootNode, { indexPaths, getChildren: this.getNodeChildren, create: this._create });\n    });\n    __publicField(this, \"replace\", (indexPath, node) => {\n      return this._replace(this.rootNode, indexPath, node);\n    });\n    __publicField(this, \"remove\", (indexPaths) => {\n      return this._remove(this.rootNode, indexPaths);\n    });\n    __publicField(this, \"insertBefore\", (indexPath, nodes) => {\n      const parentNode = this.getParentNode(indexPath);\n      return parentNode ? this._insert(this.rootNode, indexPath, nodes) : void 0;\n    });\n    __publicField(this, \"insertAfter\", (indexPath, nodes) => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const nextIndex2 = [...indexPath.slice(0, -1), indexPath[indexPath.length - 1] + 1];\n      return this._insert(this.rootNode, nextIndex2, nodes);\n    });\n    __publicField(this, \"move\", (fromIndexPaths, toIndexPath) => {\n      return this._move(this.rootNode, fromIndexPaths, toIndexPath);\n    });\n    __publicField(this, \"toJSON\", () => {\n      return this.getValues(this.rootNode);\n    });\n    this.rootNode = options.rootNode;\n  }\n};\nfunction flattenedToTree(nodes) {\n  let rootNode = {\n    value: \"ROOT\"\n  };\n  nodes.map((node) => {\n    const { indexPath, label, value } = node;\n    if (!indexPath.length) {\n      Object.assign(rootNode, { label, value, children: [] });\n      return;\n    }\n    rootNode = insert2(rootNode, {\n      at: indexPath,\n      nodes: [compact({ label, value })],\n      getChildren: (node2) => node2.children ?? [],\n      create: (node2, children) => {\n        return compact({ ...node2, children });\n      }\n    });\n  });\n  return new TreeCollection({ rootNode });\n}\nfunction filePathToTree(paths) {\n  const rootNode = {\n    label: \"\",\n    value: \"ROOT\",\n    children: []\n  };\n  paths.forEach((path) => {\n    const parts = path.split(\"/\");\n    let currentNode = rootNode;\n    parts.forEach((part) => {\n      let childNode = currentNode.children?.find((child) => child.label === part);\n      if (!childNode) {\n        childNode = {\n          value: parts.slice(0, parts.indexOf(part) + 1).join(\"/\"),\n          label: part\n        };\n        currentNode.children || (currentNode.children = []);\n        currentNode.children.push(childNode);\n      }\n      currentNode = childNode;\n    });\n  });\n  return new TreeCollection({ rootNode });\n}\nvar fallback2 = {\n  nodeToValue(node) {\n    if (typeof node === \"string\") return node;\n    if (isObject(node) && hasProp(node, \"value\")) return node.value;\n    return \"\";\n  },\n  nodeToString(node) {\n    if (typeof node === \"string\") return node;\n    if (isObject(node) && hasProp(node, \"label\")) return node.label;\n    return fallback2.nodeToValue(node);\n  },\n  isNodeDisabled(node) {\n    if (isObject(node) && hasProp(node, \"disabled\")) return !!node.disabled;\n    return false;\n  },\n  nodeToChildren(node) {\n    return node.children;\n  }\n};\nvar Selection = class _Selection extends Set {\n  constructor(values = []) {\n    super(values);\n    __publicField(this, \"selectionMode\", \"single\");\n    __publicField(this, \"deselectable\", true);\n    __publicField(this, \"copy\", () => {\n      const clone = new _Selection([...this]);\n      return this.sync(clone);\n    });\n    __publicField(this, \"sync\", (other) => {\n      other.selectionMode = this.selectionMode;\n      other.deselectable = this.deselectable;\n      return other;\n    });\n    __publicField(this, \"isEmpty\", () => {\n      return this.size === 0;\n    });\n    __publicField(this, \"isSelected\", (value) => {\n      if (this.selectionMode === \"none\" || value == null) {\n        return false;\n      }\n      return this.has(value);\n    });\n    __publicField(this, \"canSelect\", (collection, value) => {\n      return this.selectionMode !== \"none\" || !collection.getItemDisabled(collection.find(value));\n    });\n    __publicField(this, \"firstSelectedValue\", (collection) => {\n      let firstValue = null;\n      for (let value of this) {\n        if (!firstValue || collection.compareValue(value, firstValue) < 0) {\n          firstValue = value;\n        }\n      }\n      return firstValue;\n    });\n    __publicField(this, \"lastSelectedValue\", (collection) => {\n      let lastValue = null;\n      for (let value of this) {\n        if (!lastValue || collection.compareValue(value, lastValue) > 0) {\n          lastValue = value;\n        }\n      }\n      return lastValue;\n    });\n    __publicField(this, \"extendSelection\", (collection, anchorValue, targetValue) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      if (this.selectionMode === \"single\") {\n        return this.replaceSelection(collection, targetValue);\n      }\n      const selection = this.copy();\n      const lastSelected = Array.from(this).pop();\n      for (let key of collection.getValueRange(anchorValue, lastSelected ?? targetValue)) {\n        selection.delete(key);\n      }\n      for (let key of collection.getValueRange(targetValue, anchorValue)) {\n        if (this.canSelect(collection, key)) {\n          selection.add(key);\n        }\n      }\n      return selection;\n    });\n    __publicField(this, \"toggleSelection\", (collection, value) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      if (this.selectionMode === \"single\" && !this.isSelected(value)) {\n        return this.replaceSelection(collection, value);\n      }\n      const selection = this.copy();\n      if (selection.has(value)) {\n        selection.delete(value);\n      } else if (selection.canSelect(collection, value)) {\n        selection.add(value);\n      }\n      return selection;\n    });\n    __publicField(this, \"replaceSelection\", (collection, value) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      if (value == null) {\n        return this;\n      }\n      if (!this.canSelect(collection, value)) {\n        return this;\n      }\n      const selection = new _Selection([value]);\n      return this.sync(selection);\n    });\n    __publicField(this, \"setSelection\", (values) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      let selection = new _Selection();\n      for (let value of values) {\n        if (value != null) {\n          selection.add(value);\n          if (this.selectionMode === \"single\") {\n            break;\n          }\n        }\n      }\n      return this.sync(selection);\n    });\n    __publicField(this, \"clearSelection\", () => {\n      const selection = this.copy();\n      if (selection.deselectable && selection.size > 0) {\n        selection.clear();\n      }\n      return selection;\n    });\n    __publicField(this, \"select\", (collection, value, forceToggle) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      if (this.selectionMode === \"single\") {\n        if (this.isSelected(value) && this.deselectable) {\n          return this.toggleSelection(collection, value);\n        } else {\n          return this.replaceSelection(collection, value);\n        }\n      } else if (this.selectionMode === \"multiple\" || forceToggle) {\n        return this.toggleSelection(collection, value);\n      } else {\n        return this.replaceSelection(collection, value);\n      }\n    });\n    __publicField(this, \"deselect\", (value) => {\n      const selection = this.copy();\n      selection.delete(value);\n      return selection;\n    });\n    __publicField(this, \"isEqual\", (other) => {\n      return isEqual(Array.from(this), Array.from(other));\n    });\n  }\n};\n\nexport { GridCollection, ListCollection, Selection, TreeCollection, filePathToTree, flattenedToTree, isGridCollection, isListCollection };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}