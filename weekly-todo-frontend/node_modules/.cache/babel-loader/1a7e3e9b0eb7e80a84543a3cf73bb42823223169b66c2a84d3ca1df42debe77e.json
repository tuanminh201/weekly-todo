{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { raf, trackPointerMove, addDomEvent, queryAll, getTabbables, dataAttr, getEventKey, ariaAttr, getEventTarget, isFocusable } from '@zag-js/dom-query';\nimport { clampValue, prevIndex, nextIndex, add, remove, uniq, isObject, ensureProps, createSplitProps, throttle } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { getScrollSnapPositions, findSnapPoint } from '@zag-js/scroll-snap';\nimport { createProps } from '@zag-js/types';\n\n// src/carousel.anatomy.ts\nvar anatomy = createAnatomy(\"carousel\").parts(\"root\", \"itemGroup\", \"item\", \"control\", \"nextTrigger\", \"prevTrigger\", \"indicatorGroup\", \"indicator\", \"autoplayTrigger\");\nvar parts = anatomy.build();\nvar getRootId = ctx => ctx.ids?.root ?? `carousel:${ctx.id}`;\nvar getItemId = (ctx, index) => ctx.ids?.item?.(index) ?? `carousel:${ctx.id}:item:${index}`;\nvar getItemGroupId = ctx => ctx.ids?.itemGroup ?? `carousel:${ctx.id}:item-group`;\nvar getNextTriggerId = ctx => ctx.ids?.nextTrigger ?? `carousel:${ctx.id}:next-trigger`;\nvar getPrevTriggerId = ctx => ctx.ids?.prevTrigger ?? `carousel:${ctx.id}:prev-trigger`;\nvar getIndicatorGroupId = ctx => ctx.ids?.indicatorGroup ?? `carousel:${ctx.id}:indicator-group`;\nvar getIndicatorId = (ctx, index) => ctx.ids?.indicator?.(index) ?? `carousel:${ctx.id}:indicator:${index}`;\nvar getItemGroupEl = ctx => ctx.getById(getItemGroupId(ctx));\nvar getItemEls = ctx => queryAll(getItemGroupEl(ctx), `[data-part=item]`);\nvar getIndicatorEl = (ctx, page) => ctx.getById(getIndicatorId(ctx, page));\nvar syncTabIndex = ctx => {\n  const el = getItemGroupEl(ctx);\n  if (!el) return;\n  const tabbables = getTabbables(el);\n  if (tabbables.length > 0) {\n    el.removeAttribute(\"tabindex\");\n  } else {\n    el.setAttribute(\"tabindex\", \"0\");\n  }\n};\n\n// src/carousel.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    context,\n    computed,\n    send,\n    scope,\n    prop\n  } = service;\n  const isPlaying = state.matches(\"autoplay\");\n  const isDragging = state.matches(\"dragging\");\n  const canScrollNext = computed(\"canScrollNext\");\n  const canScrollPrev = computed(\"canScrollPrev\");\n  const horizontal = computed(\"isHorizontal\");\n  const pageSnapPoints = Array.from(context.get(\"pageSnapPoints\"));\n  const page = context.get(\"page\");\n  const slidesPerPage = prop(\"slidesPerPage\");\n  const padding = prop(\"padding\");\n  const translations = prop(\"translations\");\n  return {\n    isPlaying,\n    isDragging,\n    page,\n    pageSnapPoints,\n    canScrollNext,\n    canScrollPrev,\n    getProgress() {\n      return page / pageSnapPoints.length;\n    },\n    scrollToIndex(index, instant) {\n      send({\n        type: \"INDEX.SET\",\n        index,\n        instant\n      });\n    },\n    scrollTo(index, instant) {\n      send({\n        type: \"PAGE.SET\",\n        index,\n        instant\n      });\n    },\n    scrollNext(instant) {\n      send({\n        type: \"PAGE.NEXT\",\n        instant\n      });\n    },\n    scrollPrev(instant) {\n      send({\n        type: \"PAGE.PREV\",\n        instant\n      });\n    },\n    play() {\n      send({\n        type: \"AUTOPLAY.START\"\n      });\n    },\n    pause() {\n      send({\n        type: \"AUTOPLAY.PAUSE\"\n      });\n    },\n    isInView(index) {\n      return Array.from(context.get(\"slidesInView\")).includes(index);\n    },\n    refresh() {\n      send({\n        type: \"SNAP.REFRESH\"\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        role: \"region\",\n        \"aria-roledescription\": \"carousel\",\n        \"data-orientation\": prop(\"orientation\"),\n        dir: prop(\"dir\"),\n        style: {\n          \"--slides-per-page\": slidesPerPage,\n          \"--slide-spacing\": prop(\"spacing\"),\n          \"--slide-item-size\": \"calc(100% / var(--slides-per-page) - var(--slide-spacing) * (var(--slides-per-page) - 1) / var(--slides-per-page))\"\n        }\n      });\n    },\n    getItemGroupProps() {\n      return normalize.element({\n        ...parts.itemGroup.attrs,\n        id: getItemGroupId(scope),\n        \"data-orientation\": prop(\"orientation\"),\n        \"data-dragging\": dataAttr(isDragging),\n        dir: prop(\"dir\"),\n        \"aria-live\": isPlaying ? \"off\" : \"polite\",\n        onMouseDown(event) {\n          if (!prop(\"allowMouseDrag\")) return;\n          if (event.button !== 0) return;\n          if (event.defaultPrevented) return;\n          const target = getEventTarget(event);\n          if (isFocusable(target) && target !== event.currentTarget) return;\n          event.preventDefault();\n          send({\n            type: \"DRAGGING.START\"\n          });\n        },\n        onWheel: throttle(() => {\n          send({\n            type: \"USER.SCROLL\"\n          });\n        }, 150),\n        onTouchStart() {\n          send({\n            type: \"USER.SCROLL\"\n          });\n        },\n        style: {\n          display: \"grid\",\n          gap: \"var(--slide-spacing)\",\n          scrollSnapType: [horizontal ? \"x\" : \"y\", prop(\"snapType\")].join(\" \"),\n          gridAutoFlow: horizontal ? \"column\" : \"row\",\n          scrollbarWidth: \"none\",\n          overscrollBehavior: \"contain\",\n          [horizontal ? \"gridAutoColumns\" : \"gridAutoRows\"]: \"var(--slide-item-size)\",\n          [horizontal ? \"scrollPaddingInline\" : \"scrollPaddingBlock\"]: padding,\n          [horizontal ? \"paddingInline\" : \"paddingBlock\"]: padding,\n          [horizontal ? \"overflowX\" : \"overflowY\"]: \"auto\"\n        }\n      });\n    },\n    getItemProps(props2) {\n      const isInView = context.get(\"slidesInView\").includes(props2.index);\n      return normalize.element({\n        ...parts.item.attrs,\n        id: getItemId(scope, props2.index),\n        dir: prop(\"dir\"),\n        role: \"group\",\n        \"data-index\": props2.index,\n        \"data-inview\": dataAttr(isInView),\n        \"aria-roledescription\": \"slide\",\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-label\": translations.item(props2.index, prop(\"slideCount\")),\n        \"aria-hidden\": ariaAttr(!isInView),\n        style: {\n          scrollSnapAlign: (() => {\n            const snapAlign = props2.snapAlign ?? \"start\";\n            const slidesPerMove = prop(\"slidesPerMove\");\n            const perMove = slidesPerMove === \"auto\" ? Math.floor(prop(\"slidesPerPage\")) : slidesPerMove;\n            const shouldSnap = (props2.index + perMove) % perMove === 0;\n            return shouldSnap ? snapAlign : void 0;\n          })()\n        }\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        \"data-orientation\": prop(\"orientation\")\n      });\n    },\n    getPrevTriggerProps() {\n      return normalize.button({\n        ...parts.prevTrigger.attrs,\n        id: getPrevTriggerId(scope),\n        type: \"button\",\n        disabled: !canScrollPrev,\n        dir: prop(\"dir\"),\n        \"aria-label\": translations.prevTrigger,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-controls\": getItemGroupId(scope),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"PAGE.PREV\",\n            src: \"trigger\"\n          });\n        }\n      });\n    },\n    getNextTriggerProps() {\n      return normalize.button({\n        ...parts.nextTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getNextTriggerId(scope),\n        type: \"button\",\n        \"aria-label\": translations.nextTrigger,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-controls\": getItemGroupId(scope),\n        disabled: !canScrollNext,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"PAGE.NEXT\",\n            src: \"trigger\"\n          });\n        }\n      });\n    },\n    getIndicatorGroupProps() {\n      return normalize.element({\n        ...parts.indicatorGroup.attrs,\n        dir: prop(\"dir\"),\n        id: getIndicatorGroupId(scope),\n        \"data-orientation\": prop(\"orientation\"),\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          const src = \"indicator\";\n          const keyMap = {\n            ArrowDown(event2) {\n              if (horizontal) return;\n              send({\n                type: \"PAGE.NEXT\",\n                src\n              });\n              event2.preventDefault();\n            },\n            ArrowUp(event2) {\n              if (horizontal) return;\n              send({\n                type: \"PAGE.PREV\",\n                src\n              });\n              event2.preventDefault();\n            },\n            ArrowRight(event2) {\n              if (!horizontal) return;\n              send({\n                type: \"PAGE.NEXT\",\n                src\n              });\n              event2.preventDefault();\n            },\n            ArrowLeft(event2) {\n              if (!horizontal) return;\n              send({\n                type: \"PAGE.PREV\",\n                src\n              });\n              event2.preventDefault();\n            },\n            Home(event2) {\n              send({\n                type: \"PAGE.SET\",\n                index: 0,\n                src\n              });\n              event2.preventDefault();\n            },\n            End(event2) {\n              send({\n                type: \"PAGE.SET\",\n                index: pageSnapPoints.length - 1,\n                src\n              });\n              event2.preventDefault();\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation: prop(\"orientation\")\n          });\n          const exec = keyMap[key];\n          exec?.(event);\n        }\n      });\n    },\n    getIndicatorProps(props2) {\n      return normalize.button({\n        ...parts.indicator.attrs,\n        dir: prop(\"dir\"),\n        id: getIndicatorId(scope, props2.index),\n        type: \"button\",\n        \"data-orientation\": prop(\"orientation\"),\n        \"data-index\": props2.index,\n        \"data-readonly\": dataAttr(props2.readOnly),\n        \"data-current\": dataAttr(props2.index === page),\n        \"aria-label\": translations.indicator(props2.index),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (props2.readOnly) return;\n          send({\n            type: \"PAGE.SET\",\n            index: props2.index,\n            src: \"indicator\"\n          });\n        }\n      });\n    },\n    getAutoplayTriggerProps() {\n      return normalize.button({\n        ...parts.autoplayTrigger.attrs,\n        type: \"button\",\n        \"data-orientation\": prop(\"orientation\"),\n        \"data-pressed\": dataAttr(isPlaying),\n        \"aria-label\": isPlaying ? translations.autoplayStop : translations.autoplayStart,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: isPlaying ? \"AUTOPLAY.PAUSE\" : \"AUTOPLAY.START\"\n          });\n        }\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    ensureProps(props2, [\"slideCount\"], \"carousel\");\n    return {\n      dir: \"ltr\",\n      defaultPage: 0,\n      orientation: \"horizontal\",\n      snapType: \"mandatory\",\n      loop: !!props2.autoplay,\n      slidesPerPage: 1,\n      slidesPerMove: \"auto\",\n      spacing: \"0px\",\n      autoplay: false,\n      allowMouseDrag: false,\n      inViewThreshold: 0.6,\n      ...props2,\n      translations: {\n        nextTrigger: \"Next slide\",\n        prevTrigger: \"Previous slide\",\n        indicator: index => `Go to slide ${index + 1}`,\n        item: (index, count) => `${index + 1} of ${count}`,\n        autoplayStart: \"Start slide rotation\",\n        autoplayStop: \"Stop slide rotation\",\n        ...props2.translations\n      }\n    };\n  },\n  refs() {\n    return {\n      timeoutRef: void 0\n    };\n  },\n  initialState({\n    prop\n  }) {\n    return prop(\"autoplay\") ? \"autoplay\" : \"idle\";\n  },\n  context({\n    prop,\n    bindable,\n    getContext\n  }) {\n    return {\n      page: bindable(() => ({\n        defaultValue: prop(\"defaultPage\"),\n        value: prop(\"page\"),\n        onChange(page) {\n          const ctx = getContext();\n          const pageSnapPoints = ctx.get(\"pageSnapPoints\");\n          prop(\"onPageChange\")?.({\n            page,\n            pageSnapPoint: pageSnapPoints[page]\n          });\n        }\n      })),\n      pageSnapPoints: bindable(() => {\n        return {\n          defaultValue: getPageSnapPoints(prop(\"slideCount\"), prop(\"slidesPerMove\"), prop(\"slidesPerPage\"))\n        };\n      }),\n      slidesInView: bindable(() => ({\n        defaultValue: []\n      }))\n    };\n  },\n  computed: {\n    isRtl: ({\n      prop\n    }) => prop(\"dir\") === \"rtl\",\n    isHorizontal: ({\n      prop\n    }) => prop(\"orientation\") === \"horizontal\",\n    canScrollNext: ({\n      prop,\n      context\n    }) => prop(\"loop\") || context.get(\"page\") < context.get(\"pageSnapPoints\").length - 1,\n    canScrollPrev: ({\n      prop,\n      context\n    }) => prop(\"loop\") || context.get(\"page\") > 0,\n    autoplayInterval: ({\n      prop\n    }) => {\n      const autoplay = prop(\"autoplay\");\n      return isObject(autoplay) ? autoplay.delay : 4e3;\n    }\n  },\n  watch({\n    track,\n    action,\n    context,\n    prop\n  }) {\n    track([() => prop(\"slidesPerPage\"), () => prop(\"slidesPerMove\")], () => {\n      action([\"setSnapPoints\"]);\n    });\n    track([() => context.get(\"page\")], () => {\n      action([\"scrollToPage\", \"focusIndicatorEl\"]);\n    });\n    track([() => prop(\"orientation\")], () => {\n      action([\"setSnapPoints\", \"scrollToPage\"]);\n    });\n  },\n  on: {\n    \"PAGE.NEXT\": {\n      target: \"idle\",\n      actions: [\"clearScrollEndTimer\", \"setNextPage\"]\n    },\n    \"PAGE.PREV\": {\n      target: \"idle\",\n      actions: [\"clearScrollEndTimer\", \"setPrevPage\"]\n    },\n    \"PAGE.SET\": {\n      target: \"idle\",\n      actions: [\"clearScrollEndTimer\", \"setPage\"]\n    },\n    \"INDEX.SET\": {\n      target: \"idle\",\n      actions: [\"clearScrollEndTimer\", \"setMatchingPage\"]\n    },\n    \"SNAP.REFRESH\": {\n      actions: [\"setSnapPoints\", \"clampPage\"]\n    },\n    \"PAGE.SCROLL\": {\n      actions: [\"scrollToPage\"]\n    }\n  },\n  effects: [\"trackSlideMutation\", \"trackSlideIntersections\", \"trackSlideResize\"],\n  entry: [\"setSnapPoints\", \"setPage\"],\n  exit: [\"clearScrollEndTimer\"],\n  states: {\n    idle: {\n      on: {\n        \"DRAGGING.START\": {\n          target: \"dragging\",\n          actions: [\"invokeDragStart\"]\n        },\n        \"AUTOPLAY.START\": {\n          target: \"autoplay\",\n          actions: [\"invokeAutoplayStart\"]\n        },\n        \"USER.SCROLL\": {\n          target: \"userScroll\"\n        }\n      }\n    },\n    dragging: {\n      effects: [\"trackPointerMove\"],\n      entry: [\"disableScrollSnap\"],\n      on: {\n        DRAGGING: {\n          actions: [\"scrollSlides\", \"invokeDragging\"]\n        },\n        \"DRAGGING.END\": {\n          target: \"idle\",\n          actions: [\"endDragging\", \"invokeDraggingEnd\"]\n        }\n      }\n    },\n    userScroll: {\n      effects: [\"trackScroll\"],\n      on: {\n        \"SCROLL.END\": {\n          target: \"idle\",\n          actions: [\"setClosestPage\"]\n        }\n      }\n    },\n    autoplay: {\n      effects: [\"trackDocumentVisibility\", \"trackScroll\", \"autoUpdateSlide\"],\n      exit: [\"invokeAutoplayEnd\"],\n      on: {\n        \"AUTOPLAY.TICK\": {\n          actions: [\"setNextPage\", \"invokeAutoplay\"]\n        },\n        \"DRAGGING.START\": {\n          target: \"dragging\",\n          actions: [\"invokeDragStart\"]\n        },\n        \"AUTOPLAY.PAUSE\": {\n          target: \"idle\"\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      autoUpdateSlide({\n        computed,\n        send\n      }) {\n        const id = setInterval(() => {\n          send({\n            type: \"AUTOPLAY.TICK\",\n            src: \"autoplay.interval\"\n          });\n        }, computed(\"autoplayInterval\"));\n        return () => clearInterval(id);\n      },\n      trackSlideMutation({\n        scope,\n        send\n      }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const win = scope.getWin();\n        const observer = new win.MutationObserver(() => {\n          send({\n            type: \"SNAP.REFRESH\",\n            src: \"slide.mutation\"\n          });\n          syncTabIndex(scope);\n        });\n        syncTabIndex(scope);\n        observer.observe(el, {\n          childList: true,\n          subtree: true\n        });\n        return () => observer.disconnect();\n      },\n      trackSlideResize({\n        scope,\n        send\n      }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const win = scope.getWin();\n        const exec = () => {\n          send({\n            type: \"SNAP.REFRESH\",\n            src: \"slide.resize\"\n          });\n        };\n        raf(() => {\n          exec();\n          raf(() => {\n            send({\n              type: \"PAGE.SCROLL\",\n              instant: true\n            });\n          });\n        });\n        const observer = new win.ResizeObserver(exec);\n        getItemEls(scope).forEach(slide => observer.observe(slide));\n        return () => observer.disconnect();\n      },\n      trackSlideIntersections({\n        scope,\n        prop,\n        context\n      }) {\n        const el = getItemGroupEl(scope);\n        const win = scope.getWin();\n        const observer = new win.IntersectionObserver(entries => {\n          const slidesInView = entries.reduce((acc, entry) => {\n            const target = entry.target;\n            const index = Number(target.dataset.index ?? \"-1\");\n            if (index == null || Number.isNaN(index) || index === -1) return acc;\n            return entry.isIntersecting ? add(acc, index) : remove(acc, index);\n          }, context.get(\"slidesInView\"));\n          context.set(\"slidesInView\", uniq(slidesInView));\n        }, {\n          root: el,\n          threshold: prop(\"inViewThreshold\")\n        });\n        getItemEls(scope).forEach(slide => observer.observe(slide));\n        return () => observer.disconnect();\n      },\n      trackScroll({\n        send,\n        refs,\n        scope\n      }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const onScroll = () => {\n          clearTimeout(refs.get(\"timeoutRef\"));\n          refs.set(\"timeoutRef\", void 0);\n          refs.set(\"timeoutRef\", setTimeout(() => {\n            send({\n              type: \"SCROLL.END\"\n            });\n          }, 150));\n        };\n        return addDomEvent(el, \"scroll\", onScroll, {\n          passive: true\n        });\n      },\n      trackDocumentVisibility({\n        scope,\n        send\n      }) {\n        const doc = scope.getDoc();\n        const onVisibilityChange = () => {\n          if (doc.visibilityState === \"visible\") return;\n          send({\n            type: \"AUTOPLAY.PAUSE\",\n            src: \"doc.hidden\"\n          });\n        };\n        return addDomEvent(doc, \"visibilitychange\", onVisibilityChange);\n      },\n      trackPointerMove({\n        scope,\n        send\n      }) {\n        const doc = scope.getDoc();\n        return trackPointerMove(doc, {\n          onPointerMove({\n            event\n          }) {\n            send({\n              type: \"DRAGGING\",\n              left: -event.movementX,\n              top: -event.movementY\n            });\n          },\n          onPointerUp() {\n            send({\n              type: \"DRAGGING.END\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      clearScrollEndTimer({\n        refs\n      }) {\n        if (refs.get(\"timeoutRef\") == null) return;\n        clearTimeout(refs.get(\"timeoutRef\"));\n        refs.set(\"timeoutRef\", void 0);\n      },\n      scrollToPage({\n        context,\n        event,\n        scope,\n        computed\n      }) {\n        const behavior = event.instant ? \"instant\" : \"smooth\";\n        const index = clampValue(event.index ?? context.get(\"page\"), 0, context.get(\"pageSnapPoints\").length - 1);\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const axis = computed(\"isHorizontal\") ? \"left\" : \"top\";\n        el.scrollTo({\n          [axis]: context.get(\"pageSnapPoints\")[index],\n          behavior\n        });\n      },\n      setClosestPage({\n        context,\n        scope,\n        computed\n      }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const scrollPosition = computed(\"isHorizontal\") ? el.scrollLeft : el.scrollTop;\n        const page = context.get(\"pageSnapPoints\").findIndex(point => Math.abs(point - scrollPosition) < 1);\n        if (page === -1) return;\n        context.set(\"page\", page);\n      },\n      setNextPage({\n        context,\n        prop,\n        state\n      }) {\n        const loop = state.matches(\"autoplay\") || prop(\"loop\");\n        const page = nextIndex(context.get(\"pageSnapPoints\"), context.get(\"page\"), {\n          loop\n        });\n        context.set(\"page\", page);\n      },\n      setPrevPage({\n        context,\n        prop,\n        state\n      }) {\n        const loop = state.matches(\"autoplay\") || prop(\"loop\");\n        const page = prevIndex(context.get(\"pageSnapPoints\"), context.get(\"page\"), {\n          loop\n        });\n        context.set(\"page\", page);\n      },\n      setMatchingPage({\n        context,\n        event,\n        computed,\n        scope\n      }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const snapPoint = findSnapPoint(el, computed(\"isHorizontal\") ? \"x\" : \"y\", node => node.dataset.index === event.index.toString());\n        if (snapPoint == null) return;\n        const page = context.get(\"pageSnapPoints\").findIndex(point => Math.abs(point - snapPoint) < 1);\n        context.set(\"page\", page);\n      },\n      setPage({\n        context,\n        event\n      }) {\n        const page = event.index ?? context.get(\"page\");\n        context.set(\"page\", page);\n      },\n      clampPage({\n        context\n      }) {\n        const index = clampValue(context.get(\"page\"), 0, context.get(\"pageSnapPoints\").length - 1);\n        context.set(\"page\", index);\n      },\n      setSnapPoints({\n        context,\n        computed,\n        scope\n      }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const scrollSnapPoints = getScrollSnapPositions(el);\n        context.set(\"pageSnapPoints\", computed(\"isHorizontal\") ? scrollSnapPoints.x : scrollSnapPoints.y);\n      },\n      disableScrollSnap({\n        scope\n      }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const styles = getComputedStyle(el);\n        el.dataset.scrollSnapType = styles.getPropertyValue(\"scroll-snap-type\");\n        el.style.setProperty(\"scroll-snap-type\", \"none\");\n      },\n      scrollSlides({\n        scope,\n        event\n      }) {\n        const el = getItemGroupEl(scope);\n        el?.scrollBy({\n          left: event.left,\n          top: event.top,\n          behavior: \"instant\"\n        });\n      },\n      endDragging({\n        scope,\n        context,\n        computed\n      }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const startX = el.scrollLeft;\n        const startY = el.scrollTop;\n        const snapPositions = getScrollSnapPositions(el);\n        const closestX = snapPositions.x.reduce((closest, curr) => {\n          return Math.abs(curr - startX) < Math.abs(closest - startX) ? curr : closest;\n        }, snapPositions.x[0]);\n        const closestY = snapPositions.y.reduce((closest, curr) => {\n          return Math.abs(curr - startY) < Math.abs(closest - startY) ? curr : closest;\n        }, snapPositions.y[0]);\n        raf(() => {\n          el.scrollTo({\n            left: closestX,\n            top: closestY,\n            behavior: \"smooth\"\n          });\n          const closest = computed(\"isHorizontal\") ? closestX : closestY;\n          context.set(\"page\", context.get(\"pageSnapPoints\").indexOf(closest));\n          const scrollSnapType = el.dataset.scrollSnapType;\n          if (scrollSnapType) {\n            el.style.removeProperty(\"scroll-snap-type\");\n            delete el.dataset.scrollSnapType;\n          }\n        });\n      },\n      focusIndicatorEl({\n        context,\n        event,\n        scope\n      }) {\n        if (event.src !== \"indicator\") return;\n        const el = getIndicatorEl(scope, context.get(\"page\"));\n        if (!el) return;\n        raf(() => el.focus({\n          preventScroll: true\n        }));\n      },\n      invokeDragStart({\n        context,\n        prop\n      }) {\n        prop(\"onDragStatusChange\")?.({\n          type: \"dragging.start\",\n          isDragging: true,\n          page: context.get(\"page\")\n        });\n      },\n      invokeDragging({\n        context,\n        prop\n      }) {\n        prop(\"onDragStatusChange\")?.({\n          type: \"dragging\",\n          isDragging: true,\n          page: context.get(\"page\")\n        });\n      },\n      invokeDraggingEnd({\n        context,\n        prop\n      }) {\n        prop(\"onDragStatusChange\")?.({\n          type: \"dragging.end\",\n          isDragging: false,\n          page: context.get(\"page\")\n        });\n      },\n      invokeAutoplay({\n        context,\n        prop\n      }) {\n        prop(\"onAutoplayStatusChange\")?.({\n          type: \"autoplay\",\n          isPlaying: true,\n          page: context.get(\"page\")\n        });\n      },\n      invokeAutoplayStart({\n        context,\n        prop\n      }) {\n        prop(\"onAutoplayStatusChange\")?.({\n          type: \"autoplay.start\",\n          isPlaying: true,\n          page: context.get(\"page\")\n        });\n      },\n      invokeAutoplayEnd({\n        context,\n        prop\n      }) {\n        prop(\"onAutoplayStatusChange\")?.({\n          type: \"autoplay.stop\",\n          isPlaying: false,\n          page: context.get(\"page\")\n        });\n      }\n    }\n  }\n});\nfunction getPageSnapPoints(totalSlides, slidesPerMove, slidesPerPage) {\n  if (totalSlides == null) return [];\n  const snapPoints = [];\n  const perMove = slidesPerMove === \"auto\" ? Math.floor(slidesPerPage) : slidesPerMove;\n  for (let i = 0; i < totalSlides - 1; i += perMove) snapPoints.push(i);\n  return snapPoints;\n}\nvar props = createProps()([\"dir\", \"getRootNode\", \"id\", \"ids\", \"loop\", \"page\", \"defaultPage\", \"onPageChange\", \"orientation\", \"slideCount\", \"slidesPerPage\", \"slidesPerMove\", \"spacing\", \"padding\", \"autoplay\", \"allowMouseDrag\", \"inViewThreshold\", \"translations\", \"snapType\", \"onDragStatusChange\", \"onAutoplayStatusChange\"]);\nvar splitProps = createSplitProps(props);\nvar indicatorProps = createProps()([\"index\", \"readOnly\"]);\nvar splitIndicatorProps = createSplitProps(indicatorProps);\nvar itemProps = createProps()([\"index\", \"snapAlign\"]);\nvar splitItemProps = createSplitProps(itemProps);\nexport { anatomy, connect, indicatorProps, itemProps, machine, props, splitIndicatorProps, splitItemProps, splitProps };","map":{"version":3,"names":["createAnatomy","raf","trackPointerMove","addDomEvent","queryAll","getTabbables","dataAttr","getEventKey","ariaAttr","getEventTarget","isFocusable","clampValue","prevIndex","nextIndex","add","remove","uniq","isObject","ensureProps","createSplitProps","throttle","createMachine","getScrollSnapPositions","findSnapPoint","createProps","anatomy","parts","build","getRootId","ctx","ids","root","id","getItemId","index","item","getItemGroupId","itemGroup","getNextTriggerId","nextTrigger","getPrevTriggerId","prevTrigger","getIndicatorGroupId","indicatorGroup","getIndicatorId","indicator","getItemGroupEl","getById","getItemEls","getIndicatorEl","page","syncTabIndex","el","tabbables","length","removeAttribute","setAttribute","connect","service","normalize","state","context","computed","send","scope","prop","isPlaying","matches","isDragging","canScrollNext","canScrollPrev","horizontal","pageSnapPoints","Array","from","get","slidesPerPage","padding","translations","getProgress","scrollToIndex","instant","type","scrollTo","scrollNext","scrollPrev","play","pause","isInView","includes","refresh","getRootProps","element","attrs","role","dir","style","getItemGroupProps","onMouseDown","event","button","defaultPrevented","target","currentTarget","preventDefault","onWheel","onTouchStart","display","gap","scrollSnapType","join","gridAutoFlow","scrollbarWidth","overscrollBehavior","getItemProps","props2","scrollSnapAlign","snapAlign","slidesPerMove","perMove","Math","floor","shouldSnap","getControlProps","control","getPrevTriggerProps","disabled","onClick","src","getNextTriggerProps","getIndicatorGroupProps","onKeyDown","keyMap","ArrowDown","event2","ArrowUp","ArrowRight","ArrowLeft","Home","End","key","orientation","exec","getIndicatorProps","readOnly","getAutoplayTriggerProps","autoplayTrigger","autoplayStop","autoplayStart","machine","props","defaultPage","snapType","loop","autoplay","spacing","allowMouseDrag","inViewThreshold","count","refs","timeoutRef","initialState","bindable","getContext","defaultValue","value","onChange","pageSnapPoint","getPageSnapPoints","slidesInView","isRtl","isHorizontal","autoplayInterval","delay","watch","track","action","on","actions","effects","entry","exit","states","idle","dragging","DRAGGING","userScroll","implementations","autoUpdateSlide","setInterval","clearInterval","trackSlideMutation","win","getWin","observer","MutationObserver","observe","childList","subtree","disconnect","trackSlideResize","ResizeObserver","forEach","slide","trackSlideIntersections","IntersectionObserver","entries","reduce","acc","Number","dataset","isNaN","isIntersecting","set","threshold","trackScroll","onScroll","clearTimeout","setTimeout","passive","trackDocumentVisibility","doc","getDoc","onVisibilityChange","visibilityState","onPointerMove","left","movementX","top","movementY","onPointerUp","clearScrollEndTimer","scrollToPage","behavior","axis","setClosestPage","scrollPosition","scrollLeft","scrollTop","findIndex","point","abs","setNextPage","setPrevPage","setMatchingPage","snapPoint","node","toString","setPage","clampPage","setSnapPoints","scrollSnapPoints","x","y","disableScrollSnap","styles","getComputedStyle","getPropertyValue","setProperty","scrollSlides","scrollBy","endDragging","startX","startY","snapPositions","closestX","closest","curr","closestY","indexOf","removeProperty","focusIndicatorEl","focus","preventScroll","invokeDragStart","invokeDragging","invokeDraggingEnd","invokeAutoplay","invokeAutoplayStart","invokeAutoplayEnd","totalSlides","snapPoints","i","push","splitProps","indicatorProps","splitIndicatorProps","itemProps","splitItemProps"],"sources":["C:/Users/tuanl/weekly-todo-frontend/node_modules/@chakra-ui/react/node_modules/@zag-js/carousel/dist/index.mjs"],"sourcesContent":["import { createAnatomy } from '@zag-js/anatomy';\nimport { raf, trackPointerMove, addDomEvent, queryAll, getTabbables, dataAttr, getEventKey, ariaAttr, getEventTarget, isFocusable } from '@zag-js/dom-query';\nimport { clampValue, prevIndex, nextIndex, add, remove, uniq, isObject, ensureProps, createSplitProps, throttle } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { getScrollSnapPositions, findSnapPoint } from '@zag-js/scroll-snap';\nimport { createProps } from '@zag-js/types';\n\n// src/carousel.anatomy.ts\nvar anatomy = createAnatomy(\"carousel\").parts(\n  \"root\",\n  \"itemGroup\",\n  \"item\",\n  \"control\",\n  \"nextTrigger\",\n  \"prevTrigger\",\n  \"indicatorGroup\",\n  \"indicator\",\n  \"autoplayTrigger\"\n);\nvar parts = anatomy.build();\nvar getRootId = (ctx) => ctx.ids?.root ?? `carousel:${ctx.id}`;\nvar getItemId = (ctx, index) => ctx.ids?.item?.(index) ?? `carousel:${ctx.id}:item:${index}`;\nvar getItemGroupId = (ctx) => ctx.ids?.itemGroup ?? `carousel:${ctx.id}:item-group`;\nvar getNextTriggerId = (ctx) => ctx.ids?.nextTrigger ?? `carousel:${ctx.id}:next-trigger`;\nvar getPrevTriggerId = (ctx) => ctx.ids?.prevTrigger ?? `carousel:${ctx.id}:prev-trigger`;\nvar getIndicatorGroupId = (ctx) => ctx.ids?.indicatorGroup ?? `carousel:${ctx.id}:indicator-group`;\nvar getIndicatorId = (ctx, index) => ctx.ids?.indicator?.(index) ?? `carousel:${ctx.id}:indicator:${index}`;\nvar getItemGroupEl = (ctx) => ctx.getById(getItemGroupId(ctx));\nvar getItemEls = (ctx) => queryAll(getItemGroupEl(ctx), `[data-part=item]`);\nvar getIndicatorEl = (ctx, page) => ctx.getById(getIndicatorId(ctx, page));\nvar syncTabIndex = (ctx) => {\n  const el = getItemGroupEl(ctx);\n  if (!el) return;\n  const tabbables = getTabbables(el);\n  if (tabbables.length > 0) {\n    el.removeAttribute(\"tabindex\");\n  } else {\n    el.setAttribute(\"tabindex\", \"0\");\n  }\n};\n\n// src/carousel.connect.ts\nfunction connect(service, normalize) {\n  const { state, context, computed, send, scope, prop } = service;\n  const isPlaying = state.matches(\"autoplay\");\n  const isDragging = state.matches(\"dragging\");\n  const canScrollNext = computed(\"canScrollNext\");\n  const canScrollPrev = computed(\"canScrollPrev\");\n  const horizontal = computed(\"isHorizontal\");\n  const pageSnapPoints = Array.from(context.get(\"pageSnapPoints\"));\n  const page = context.get(\"page\");\n  const slidesPerPage = prop(\"slidesPerPage\");\n  const padding = prop(\"padding\");\n  const translations = prop(\"translations\");\n  return {\n    isPlaying,\n    isDragging,\n    page,\n    pageSnapPoints,\n    canScrollNext,\n    canScrollPrev,\n    getProgress() {\n      return page / pageSnapPoints.length;\n    },\n    scrollToIndex(index, instant) {\n      send({ type: \"INDEX.SET\", index, instant });\n    },\n    scrollTo(index, instant) {\n      send({ type: \"PAGE.SET\", index, instant });\n    },\n    scrollNext(instant) {\n      send({ type: \"PAGE.NEXT\", instant });\n    },\n    scrollPrev(instant) {\n      send({ type: \"PAGE.PREV\", instant });\n    },\n    play() {\n      send({ type: \"AUTOPLAY.START\" });\n    },\n    pause() {\n      send({ type: \"AUTOPLAY.PAUSE\" });\n    },\n    isInView(index) {\n      return Array.from(context.get(\"slidesInView\")).includes(index);\n    },\n    refresh() {\n      send({ type: \"SNAP.REFRESH\" });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        role: \"region\",\n        \"aria-roledescription\": \"carousel\",\n        \"data-orientation\": prop(\"orientation\"),\n        dir: prop(\"dir\"),\n        style: {\n          \"--slides-per-page\": slidesPerPage,\n          \"--slide-spacing\": prop(\"spacing\"),\n          \"--slide-item-size\": \"calc(100% / var(--slides-per-page) - var(--slide-spacing) * (var(--slides-per-page) - 1) / var(--slides-per-page))\"\n        }\n      });\n    },\n    getItemGroupProps() {\n      return normalize.element({\n        ...parts.itemGroup.attrs,\n        id: getItemGroupId(scope),\n        \"data-orientation\": prop(\"orientation\"),\n        \"data-dragging\": dataAttr(isDragging),\n        dir: prop(\"dir\"),\n        \"aria-live\": isPlaying ? \"off\" : \"polite\",\n        onMouseDown(event) {\n          if (!prop(\"allowMouseDrag\")) return;\n          if (event.button !== 0) return;\n          if (event.defaultPrevented) return;\n          const target = getEventTarget(event);\n          if (isFocusable(target) && target !== event.currentTarget) return;\n          event.preventDefault();\n          send({ type: \"DRAGGING.START\" });\n        },\n        onWheel: throttle(() => {\n          send({ type: \"USER.SCROLL\" });\n        }, 150),\n        onTouchStart() {\n          send({ type: \"USER.SCROLL\" });\n        },\n        style: {\n          display: \"grid\",\n          gap: \"var(--slide-spacing)\",\n          scrollSnapType: [horizontal ? \"x\" : \"y\", prop(\"snapType\")].join(\" \"),\n          gridAutoFlow: horizontal ? \"column\" : \"row\",\n          scrollbarWidth: \"none\",\n          overscrollBehavior: \"contain\",\n          [horizontal ? \"gridAutoColumns\" : \"gridAutoRows\"]: \"var(--slide-item-size)\",\n          [horizontal ? \"scrollPaddingInline\" : \"scrollPaddingBlock\"]: padding,\n          [horizontal ? \"paddingInline\" : \"paddingBlock\"]: padding,\n          [horizontal ? \"overflowX\" : \"overflowY\"]: \"auto\"\n        }\n      });\n    },\n    getItemProps(props2) {\n      const isInView = context.get(\"slidesInView\").includes(props2.index);\n      return normalize.element({\n        ...parts.item.attrs,\n        id: getItemId(scope, props2.index),\n        dir: prop(\"dir\"),\n        role: \"group\",\n        \"data-index\": props2.index,\n        \"data-inview\": dataAttr(isInView),\n        \"aria-roledescription\": \"slide\",\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-label\": translations.item(props2.index, prop(\"slideCount\")),\n        \"aria-hidden\": ariaAttr(!isInView),\n        style: {\n          scrollSnapAlign: (() => {\n            const snapAlign = props2.snapAlign ?? \"start\";\n            const slidesPerMove = prop(\"slidesPerMove\");\n            const perMove = slidesPerMove === \"auto\" ? Math.floor(prop(\"slidesPerPage\")) : slidesPerMove;\n            const shouldSnap = (props2.index + perMove) % perMove === 0;\n            return shouldSnap ? snapAlign : void 0;\n          })()\n        }\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        \"data-orientation\": prop(\"orientation\")\n      });\n    },\n    getPrevTriggerProps() {\n      return normalize.button({\n        ...parts.prevTrigger.attrs,\n        id: getPrevTriggerId(scope),\n        type: \"button\",\n        disabled: !canScrollPrev,\n        dir: prop(\"dir\"),\n        \"aria-label\": translations.prevTrigger,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-controls\": getItemGroupId(scope),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({ type: \"PAGE.PREV\", src: \"trigger\" });\n        }\n      });\n    },\n    getNextTriggerProps() {\n      return normalize.button({\n        ...parts.nextTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getNextTriggerId(scope),\n        type: \"button\",\n        \"aria-label\": translations.nextTrigger,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-controls\": getItemGroupId(scope),\n        disabled: !canScrollNext,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({ type: \"PAGE.NEXT\", src: \"trigger\" });\n        }\n      });\n    },\n    getIndicatorGroupProps() {\n      return normalize.element({\n        ...parts.indicatorGroup.attrs,\n        dir: prop(\"dir\"),\n        id: getIndicatorGroupId(scope),\n        \"data-orientation\": prop(\"orientation\"),\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          const src = \"indicator\";\n          const keyMap = {\n            ArrowDown(event2) {\n              if (horizontal) return;\n              send({ type: \"PAGE.NEXT\", src });\n              event2.preventDefault();\n            },\n            ArrowUp(event2) {\n              if (horizontal) return;\n              send({ type: \"PAGE.PREV\", src });\n              event2.preventDefault();\n            },\n            ArrowRight(event2) {\n              if (!horizontal) return;\n              send({ type: \"PAGE.NEXT\", src });\n              event2.preventDefault();\n            },\n            ArrowLeft(event2) {\n              if (!horizontal) return;\n              send({ type: \"PAGE.PREV\", src });\n              event2.preventDefault();\n            },\n            Home(event2) {\n              send({ type: \"PAGE.SET\", index: 0, src });\n              event2.preventDefault();\n            },\n            End(event2) {\n              send({ type: \"PAGE.SET\", index: pageSnapPoints.length - 1, src });\n              event2.preventDefault();\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation: prop(\"orientation\")\n          });\n          const exec = keyMap[key];\n          exec?.(event);\n        }\n      });\n    },\n    getIndicatorProps(props2) {\n      return normalize.button({\n        ...parts.indicator.attrs,\n        dir: prop(\"dir\"),\n        id: getIndicatorId(scope, props2.index),\n        type: \"button\",\n        \"data-orientation\": prop(\"orientation\"),\n        \"data-index\": props2.index,\n        \"data-readonly\": dataAttr(props2.readOnly),\n        \"data-current\": dataAttr(props2.index === page),\n        \"aria-label\": translations.indicator(props2.index),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (props2.readOnly) return;\n          send({ type: \"PAGE.SET\", index: props2.index, src: \"indicator\" });\n        }\n      });\n    },\n    getAutoplayTriggerProps() {\n      return normalize.button({\n        ...parts.autoplayTrigger.attrs,\n        type: \"button\",\n        \"data-orientation\": prop(\"orientation\"),\n        \"data-pressed\": dataAttr(isPlaying),\n        \"aria-label\": isPlaying ? translations.autoplayStop : translations.autoplayStart,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({ type: isPlaying ? \"AUTOPLAY.PAUSE\" : \"AUTOPLAY.START\" });\n        }\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({ props: props2 }) {\n    ensureProps(props2, [\"slideCount\"], \"carousel\");\n    return {\n      dir: \"ltr\",\n      defaultPage: 0,\n      orientation: \"horizontal\",\n      snapType: \"mandatory\",\n      loop: !!props2.autoplay,\n      slidesPerPage: 1,\n      slidesPerMove: \"auto\",\n      spacing: \"0px\",\n      autoplay: false,\n      allowMouseDrag: false,\n      inViewThreshold: 0.6,\n      ...props2,\n      translations: {\n        nextTrigger: \"Next slide\",\n        prevTrigger: \"Previous slide\",\n        indicator: (index) => `Go to slide ${index + 1}`,\n        item: (index, count) => `${index + 1} of ${count}`,\n        autoplayStart: \"Start slide rotation\",\n        autoplayStop: \"Stop slide rotation\",\n        ...props2.translations\n      }\n    };\n  },\n  refs() {\n    return {\n      timeoutRef: void 0\n    };\n  },\n  initialState({ prop }) {\n    return prop(\"autoplay\") ? \"autoplay\" : \"idle\";\n  },\n  context({ prop, bindable, getContext }) {\n    return {\n      page: bindable(() => ({\n        defaultValue: prop(\"defaultPage\"),\n        value: prop(\"page\"),\n        onChange(page) {\n          const ctx = getContext();\n          const pageSnapPoints = ctx.get(\"pageSnapPoints\");\n          prop(\"onPageChange\")?.({ page, pageSnapPoint: pageSnapPoints[page] });\n        }\n      })),\n      pageSnapPoints: bindable(() => {\n        return {\n          defaultValue: getPageSnapPoints(prop(\"slideCount\"), prop(\"slidesPerMove\"), prop(\"slidesPerPage\"))\n        };\n      }),\n      slidesInView: bindable(() => ({\n        defaultValue: []\n      }))\n    };\n  },\n  computed: {\n    isRtl: ({ prop }) => prop(\"dir\") === \"rtl\",\n    isHorizontal: ({ prop }) => prop(\"orientation\") === \"horizontal\",\n    canScrollNext: ({ prop, context }) => prop(\"loop\") || context.get(\"page\") < context.get(\"pageSnapPoints\").length - 1,\n    canScrollPrev: ({ prop, context }) => prop(\"loop\") || context.get(\"page\") > 0,\n    autoplayInterval: ({ prop }) => {\n      const autoplay = prop(\"autoplay\");\n      return isObject(autoplay) ? autoplay.delay : 4e3;\n    }\n  },\n  watch({ track, action, context, prop }) {\n    track([() => prop(\"slidesPerPage\"), () => prop(\"slidesPerMove\")], () => {\n      action([\"setSnapPoints\"]);\n    });\n    track([() => context.get(\"page\")], () => {\n      action([\"scrollToPage\", \"focusIndicatorEl\"]);\n    });\n    track([() => prop(\"orientation\")], () => {\n      action([\"setSnapPoints\", \"scrollToPage\"]);\n    });\n  },\n  on: {\n    \"PAGE.NEXT\": {\n      target: \"idle\",\n      actions: [\"clearScrollEndTimer\", \"setNextPage\"]\n    },\n    \"PAGE.PREV\": {\n      target: \"idle\",\n      actions: [\"clearScrollEndTimer\", \"setPrevPage\"]\n    },\n    \"PAGE.SET\": {\n      target: \"idle\",\n      actions: [\"clearScrollEndTimer\", \"setPage\"]\n    },\n    \"INDEX.SET\": {\n      target: \"idle\",\n      actions: [\"clearScrollEndTimer\", \"setMatchingPage\"]\n    },\n    \"SNAP.REFRESH\": {\n      actions: [\"setSnapPoints\", \"clampPage\"]\n    },\n    \"PAGE.SCROLL\": {\n      actions: [\"scrollToPage\"]\n    }\n  },\n  effects: [\"trackSlideMutation\", \"trackSlideIntersections\", \"trackSlideResize\"],\n  entry: [\"setSnapPoints\", \"setPage\"],\n  exit: [\"clearScrollEndTimer\"],\n  states: {\n    idle: {\n      on: {\n        \"DRAGGING.START\": {\n          target: \"dragging\",\n          actions: [\"invokeDragStart\"]\n        },\n        \"AUTOPLAY.START\": {\n          target: \"autoplay\",\n          actions: [\"invokeAutoplayStart\"]\n        },\n        \"USER.SCROLL\": {\n          target: \"userScroll\"\n        }\n      }\n    },\n    dragging: {\n      effects: [\"trackPointerMove\"],\n      entry: [\"disableScrollSnap\"],\n      on: {\n        DRAGGING: {\n          actions: [\"scrollSlides\", \"invokeDragging\"]\n        },\n        \"DRAGGING.END\": {\n          target: \"idle\",\n          actions: [\"endDragging\", \"invokeDraggingEnd\"]\n        }\n      }\n    },\n    userScroll: {\n      effects: [\"trackScroll\"],\n      on: {\n        \"SCROLL.END\": {\n          target: \"idle\",\n          actions: [\"setClosestPage\"]\n        }\n      }\n    },\n    autoplay: {\n      effects: [\"trackDocumentVisibility\", \"trackScroll\", \"autoUpdateSlide\"],\n      exit: [\"invokeAutoplayEnd\"],\n      on: {\n        \"AUTOPLAY.TICK\": {\n          actions: [\"setNextPage\", \"invokeAutoplay\"]\n        },\n        \"DRAGGING.START\": {\n          target: \"dragging\",\n          actions: [\"invokeDragStart\"]\n        },\n        \"AUTOPLAY.PAUSE\": {\n          target: \"idle\"\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      autoUpdateSlide({ computed, send }) {\n        const id = setInterval(() => {\n          send({ type: \"AUTOPLAY.TICK\", src: \"autoplay.interval\" });\n        }, computed(\"autoplayInterval\"));\n        return () => clearInterval(id);\n      },\n      trackSlideMutation({ scope, send }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const win = scope.getWin();\n        const observer = new win.MutationObserver(() => {\n          send({ type: \"SNAP.REFRESH\", src: \"slide.mutation\" });\n          syncTabIndex(scope);\n        });\n        syncTabIndex(scope);\n        observer.observe(el, { childList: true, subtree: true });\n        return () => observer.disconnect();\n      },\n      trackSlideResize({ scope, send }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const win = scope.getWin();\n        const exec = () => {\n          send({ type: \"SNAP.REFRESH\", src: \"slide.resize\" });\n        };\n        raf(() => {\n          exec();\n          raf(() => {\n            send({ type: \"PAGE.SCROLL\", instant: true });\n          });\n        });\n        const observer = new win.ResizeObserver(exec);\n        getItemEls(scope).forEach((slide) => observer.observe(slide));\n        return () => observer.disconnect();\n      },\n      trackSlideIntersections({ scope, prop, context }) {\n        const el = getItemGroupEl(scope);\n        const win = scope.getWin();\n        const observer = new win.IntersectionObserver(\n          (entries) => {\n            const slidesInView = entries.reduce((acc, entry) => {\n              const target = entry.target;\n              const index = Number(target.dataset.index ?? \"-1\");\n              if (index == null || Number.isNaN(index) || index === -1) return acc;\n              return entry.isIntersecting ? add(acc, index) : remove(acc, index);\n            }, context.get(\"slidesInView\"));\n            context.set(\"slidesInView\", uniq(slidesInView));\n          },\n          {\n            root: el,\n            threshold: prop(\"inViewThreshold\")\n          }\n        );\n        getItemEls(scope).forEach((slide) => observer.observe(slide));\n        return () => observer.disconnect();\n      },\n      trackScroll({ send, refs, scope }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const onScroll = () => {\n          clearTimeout(refs.get(\"timeoutRef\"));\n          refs.set(\"timeoutRef\", void 0);\n          refs.set(\n            \"timeoutRef\",\n            setTimeout(() => {\n              send({ type: \"SCROLL.END\" });\n            }, 150)\n          );\n        };\n        return addDomEvent(el, \"scroll\", onScroll, { passive: true });\n      },\n      trackDocumentVisibility({ scope, send }) {\n        const doc = scope.getDoc();\n        const onVisibilityChange = () => {\n          if (doc.visibilityState === \"visible\") return;\n          send({ type: \"AUTOPLAY.PAUSE\", src: \"doc.hidden\" });\n        };\n        return addDomEvent(doc, \"visibilitychange\", onVisibilityChange);\n      },\n      trackPointerMove({ scope, send }) {\n        const doc = scope.getDoc();\n        return trackPointerMove(doc, {\n          onPointerMove({ event }) {\n            send({ type: \"DRAGGING\", left: -event.movementX, top: -event.movementY });\n          },\n          onPointerUp() {\n            send({ type: \"DRAGGING.END\" });\n          }\n        });\n      }\n    },\n    actions: {\n      clearScrollEndTimer({ refs }) {\n        if (refs.get(\"timeoutRef\") == null) return;\n        clearTimeout(refs.get(\"timeoutRef\"));\n        refs.set(\"timeoutRef\", void 0);\n      },\n      scrollToPage({ context, event, scope, computed }) {\n        const behavior = event.instant ? \"instant\" : \"smooth\";\n        const index = clampValue(event.index ?? context.get(\"page\"), 0, context.get(\"pageSnapPoints\").length - 1);\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const axis = computed(\"isHorizontal\") ? \"left\" : \"top\";\n        el.scrollTo({ [axis]: context.get(\"pageSnapPoints\")[index], behavior });\n      },\n      setClosestPage({ context, scope, computed }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const scrollPosition = computed(\"isHorizontal\") ? el.scrollLeft : el.scrollTop;\n        const page = context.get(\"pageSnapPoints\").findIndex((point) => Math.abs(point - scrollPosition) < 1);\n        if (page === -1) return;\n        context.set(\"page\", page);\n      },\n      setNextPage({ context, prop, state }) {\n        const loop = state.matches(\"autoplay\") || prop(\"loop\");\n        const page = nextIndex(context.get(\"pageSnapPoints\"), context.get(\"page\"), { loop });\n        context.set(\"page\", page);\n      },\n      setPrevPage({ context, prop, state }) {\n        const loop = state.matches(\"autoplay\") || prop(\"loop\");\n        const page = prevIndex(context.get(\"pageSnapPoints\"), context.get(\"page\"), { loop });\n        context.set(\"page\", page);\n      },\n      setMatchingPage({ context, event, computed, scope }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const snapPoint = findSnapPoint(\n          el,\n          computed(\"isHorizontal\") ? \"x\" : \"y\",\n          (node) => node.dataset.index === event.index.toString()\n        );\n        if (snapPoint == null) return;\n        const page = context.get(\"pageSnapPoints\").findIndex((point) => Math.abs(point - snapPoint) < 1);\n        context.set(\"page\", page);\n      },\n      setPage({ context, event }) {\n        const page = event.index ?? context.get(\"page\");\n        context.set(\"page\", page);\n      },\n      clampPage({ context }) {\n        const index = clampValue(context.get(\"page\"), 0, context.get(\"pageSnapPoints\").length - 1);\n        context.set(\"page\", index);\n      },\n      setSnapPoints({ context, computed, scope }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const scrollSnapPoints = getScrollSnapPositions(el);\n        context.set(\"pageSnapPoints\", computed(\"isHorizontal\") ? scrollSnapPoints.x : scrollSnapPoints.y);\n      },\n      disableScrollSnap({ scope }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const styles = getComputedStyle(el);\n        el.dataset.scrollSnapType = styles.getPropertyValue(\"scroll-snap-type\");\n        el.style.setProperty(\"scroll-snap-type\", \"none\");\n      },\n      scrollSlides({ scope, event }) {\n        const el = getItemGroupEl(scope);\n        el?.scrollBy({ left: event.left, top: event.top, behavior: \"instant\" });\n      },\n      endDragging({ scope, context, computed }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const startX = el.scrollLeft;\n        const startY = el.scrollTop;\n        const snapPositions = getScrollSnapPositions(el);\n        const closestX = snapPositions.x.reduce((closest, curr) => {\n          return Math.abs(curr - startX) < Math.abs(closest - startX) ? curr : closest;\n        }, snapPositions.x[0]);\n        const closestY = snapPositions.y.reduce((closest, curr) => {\n          return Math.abs(curr - startY) < Math.abs(closest - startY) ? curr : closest;\n        }, snapPositions.y[0]);\n        raf(() => {\n          el.scrollTo({ left: closestX, top: closestY, behavior: \"smooth\" });\n          const closest = computed(\"isHorizontal\") ? closestX : closestY;\n          context.set(\"page\", context.get(\"pageSnapPoints\").indexOf(closest));\n          const scrollSnapType = el.dataset.scrollSnapType;\n          if (scrollSnapType) {\n            el.style.removeProperty(\"scroll-snap-type\");\n            delete el.dataset.scrollSnapType;\n          }\n        });\n      },\n      focusIndicatorEl({ context, event, scope }) {\n        if (event.src !== \"indicator\") return;\n        const el = getIndicatorEl(scope, context.get(\"page\"));\n        if (!el) return;\n        raf(() => el.focus({ preventScroll: true }));\n      },\n      invokeDragStart({ context, prop }) {\n        prop(\"onDragStatusChange\")?.({ type: \"dragging.start\", isDragging: true, page: context.get(\"page\") });\n      },\n      invokeDragging({ context, prop }) {\n        prop(\"onDragStatusChange\")?.({ type: \"dragging\", isDragging: true, page: context.get(\"page\") });\n      },\n      invokeDraggingEnd({ context, prop }) {\n        prop(\"onDragStatusChange\")?.({ type: \"dragging.end\", isDragging: false, page: context.get(\"page\") });\n      },\n      invokeAutoplay({ context, prop }) {\n        prop(\"onAutoplayStatusChange\")?.({ type: \"autoplay\", isPlaying: true, page: context.get(\"page\") });\n      },\n      invokeAutoplayStart({ context, prop }) {\n        prop(\"onAutoplayStatusChange\")?.({ type: \"autoplay.start\", isPlaying: true, page: context.get(\"page\") });\n      },\n      invokeAutoplayEnd({ context, prop }) {\n        prop(\"onAutoplayStatusChange\")?.({ type: \"autoplay.stop\", isPlaying: false, page: context.get(\"page\") });\n      }\n    }\n  }\n});\nfunction getPageSnapPoints(totalSlides, slidesPerMove, slidesPerPage) {\n  if (totalSlides == null) return [];\n  const snapPoints = [];\n  const perMove = slidesPerMove === \"auto\" ? Math.floor(slidesPerPage) : slidesPerMove;\n  for (let i = 0; i < totalSlides - 1; i += perMove) snapPoints.push(i);\n  return snapPoints;\n}\nvar props = createProps()([\n  \"dir\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"loop\",\n  \"page\",\n  \"defaultPage\",\n  \"onPageChange\",\n  \"orientation\",\n  \"slideCount\",\n  \"slidesPerPage\",\n  \"slidesPerMove\",\n  \"spacing\",\n  \"padding\",\n  \"autoplay\",\n  \"allowMouseDrag\",\n  \"inViewThreshold\",\n  \"translations\",\n  \"snapType\",\n  \"onDragStatusChange\",\n  \"onAutoplayStatusChange\"\n]);\nvar splitProps = createSplitProps(props);\nvar indicatorProps = createProps()([\"index\", \"readOnly\"]);\nvar splitIndicatorProps = createSplitProps(indicatorProps);\nvar itemProps = createProps()([\"index\", \"snapAlign\"]);\nvar splitItemProps = createSplitProps(itemProps);\n\nexport { anatomy, connect, indicatorProps, itemProps, machine, props, splitIndicatorProps, splitItemProps, splitProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}