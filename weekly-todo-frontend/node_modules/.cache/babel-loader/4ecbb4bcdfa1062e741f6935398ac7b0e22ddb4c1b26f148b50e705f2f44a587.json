{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, queryAll, dataAttr, getEventKey, getEventPoint } from '@zag-js/dom-query';\nimport { prev, next, ensure, isEqual, setRafTimeout, ensureProps, createSplitProps } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/splitter.anatomy.ts\nvar anatomy = createAnatomy(\"splitter\").parts(\"root\", \"panel\", \"resizeTrigger\");\nvar parts = anatomy.build();\nvar getRootId = ctx => ctx.ids?.root ?? `splitter:${ctx.id}`;\nvar getResizeTriggerId = (ctx, id) => ctx.ids?.resizeTrigger?.(id) ?? `splitter:${ctx.id}:splitter:${id}`;\nvar getPanelId = (ctx, id) => ctx.ids?.panel?.(id) ?? `splitter:${ctx.id}:panel:${id}`;\nvar getGlobalCursorId = ctx => `splitter:${ctx.id}:global-cursor`;\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getResizeTriggerEl = (ctx, id) => ctx.getById(getResizeTriggerId(ctx, id));\nvar getCursor = (state, x) => {\n  let cursor = x ? \"col-resize\" : \"row-resize\";\n  if (state.isAtMin) cursor = x ? \"e-resize\" : \"s-resize\";\n  if (state.isAtMax) cursor = x ? \"w-resize\" : \"n-resize\";\n  return cursor;\n};\nvar getResizeTriggerEls = ctx => {\n  return queryAll(getRootEl(ctx), `[role=separator][data-ownedby='${CSS.escape(getRootId(ctx))}']`);\n};\nvar setupGlobalCursor = (ctx, state, x, nonce) => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  const textContent = `* { cursor: ${getCursor(state, x)} !important; }`;\n  if (styleEl) {\n    styleEl.textContent = textContent;\n  } else {\n    const style = ctx.getDoc().createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    style.id = getGlobalCursorId(ctx);\n    style.textContent = textContent;\n    ctx.getDoc().head.appendChild(style);\n  }\n};\nvar removeGlobalCursor = ctx => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  styleEl?.remove();\n};\nfunction calculateAriaValues({\n  size,\n  panels,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  ensure(firstIndex, () => \"No pivot index found\");\n  panels.forEach((panel, index) => {\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = panel;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = size[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\nfunction getAriaValue(size, panels, handleId) {\n  const [beforeId, afterId] = handleId.split(\":\");\n  const beforeIndex = panels.findIndex(panel => panel.id === beforeId);\n  const afterIndex = panels.findIndex(panel => panel.id === afterId);\n  const {\n    valueMax,\n    valueMin,\n    valueNow\n  } = calculateAriaValues({\n    size,\n    panels,\n    pivotIndices: [beforeIndex, afterIndex]\n  });\n  return {\n    beforeId,\n    afterId,\n    valueMax: Math.round(valueMax),\n    valueMin: Math.round(valueMin),\n    valueNow: valueNow != null ? Math.round(valueNow) : void 0\n  };\n}\n\n// src/utils/fuzzy.ts\nvar PRECISION = 10;\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits = PRECISION) {\n  if (actual == null || expected == null) return false;\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzySizeEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getPanelById(panels, id) {\n  const panel = panels.find(panel2 => panel2.id === id);\n  ensure(panel, () => `Panel data not found for id \"${id}\"`);\n  return panel;\n}\nfunction findPanelDataIndex(panels, panel) {\n  return panels.findIndex(prevPanel => prevPanel === panel || prevPanel.id === panel.id);\n}\nfunction findPanelIndex(panels, id) {\n  return panels.findIndex(panel => panel.id === id);\n}\nfunction panelDataHelper(panels, panel, sizes) {\n  const index = findPanelIndex(panels, panel.id);\n  const pivotIndices = index === panels.length - 1 ? [index - 1, index] : [index, index + 1];\n  const panelSize = sizes[index];\n  return {\n    ...panel,\n    panelSize,\n    pivotIndices\n  };\n}\nfunction sortPanels(panels) {\n  return panels.sort((panelA, panelB) => {\n    const orderA = panelA.order;\n    const orderB = panelB.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction getPanelLayout(panels) {\n  return panels.map(panel => panel.id).sort().join(\":\");\n}\nfunction serializePanels(panels) {\n  const keys = panels.map(panel => panel.id);\n  const sortedKeys = keys.sort();\n  const serialized = sortedKeys.map(key => {\n    const panel = panels.find(panel2 => panel2.id === key);\n    return JSON.stringify(panel);\n  });\n  return serialized.join(\",\");\n}\nfunction getPanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  sizes,\n  panels,\n  panelIndex,\n  precision = 3\n}) {\n  const size = sizes[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panels.length === 1) {\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : void 0\n  };\n}\nfunction getUnsafeDefaultSize({\n  panels,\n  size: sizes\n}) {\n  const finalSizes = Array(panels.length);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      finalSizes[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panels.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    finalSizes[index] = size;\n    remainingSize -= size;\n  }\n  return finalSizes;\n}\n\n// src/splitter.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    prop,\n    computed,\n    context,\n    scope\n  } = service;\n  const horizontal = computed(\"horizontal\");\n  const dragging = state.matches(\"dragging\");\n  const getPanelStyle = id => {\n    const panels = prop(\"panels\");\n    const panelIndex = panels.findIndex(panel => panel.id === id);\n    const defaultSize = context.initial(\"size\")[panelIndex];\n    const dragState = context.get(\"dragState\");\n    return getPanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      sizes: context.get(\"size\"),\n      panels,\n      panelIndex\n    });\n  };\n  return {\n    dragging,\n    getItems() {\n      return prop(\"panels\").flatMap((panel, index, arr) => {\n        const nextPanel = arr[index + 1];\n        if (panel && nextPanel) {\n          return [{\n            type: \"panel\",\n            id: panel.id\n          }, {\n            type: \"handle\",\n            id: `${panel.id}:${nextPanel.id}`\n          }];\n        }\n        return [{\n          type: \"panel\",\n          id: panel.id\n        }];\n      });\n    },\n    getSizes() {\n      return context.get(\"size\");\n    },\n    setSizes(size) {\n      send({\n        type: \"SIZE.SET\",\n        size\n      });\n    },\n    resetSizes() {\n      send({\n        type: \"SIZE.SET\",\n        size: context.initial(\"size\")\n      });\n    },\n    collapsePanel(id) {\n      send({\n        type: \"PANEL.COLLAPSE\",\n        id\n      });\n    },\n    expandPanel(id, minSize) {\n      send({\n        type: \"PANEL.EXPAND\",\n        id,\n        minSize\n      });\n    },\n    resizePanel(id, unsafePanelSize) {\n      send({\n        type: \"PANEL.RESIZE\",\n        id,\n        size: unsafePanelSize\n      });\n    },\n    getPanelSize(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return panelSize;\n    },\n    isPanelCollapsed(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        collapsedSize = 0,\n        collapsible,\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return collapsible === true && fuzzyNumbersEqual(panelSize, collapsedSize);\n    },\n    isPanelExpanded(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        collapsedSize = 0,\n        collapsible,\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n    },\n    getLayout() {\n      return getPanelLayout(prop(\"panels\"));\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-orientation\": prop(\"orientation\"),\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        style: {\n          display: \"flex\",\n          flexDirection: horizontal ? \"row\" : \"column\",\n          height: \"100%\",\n          width: \"100%\",\n          overflow: \"hidden\"\n        }\n      });\n    },\n    getPanelProps(props2) {\n      const {\n        id\n      } = props2;\n      return normalize.element({\n        ...parts.panel.attrs,\n        \"data-orientation\": prop(\"orientation\"),\n        dir: prop(\"dir\"),\n        \"data-id\": id,\n        \"data-index\": findPanelIndex(prop(\"panels\"), id),\n        id: getPanelId(scope, id),\n        \"data-ownedby\": getRootId(scope),\n        style: getPanelStyle(id)\n      });\n    },\n    getResizeTriggerProps(props2) {\n      const {\n        id,\n        disabled\n      } = props2;\n      const aria = getAriaValue(context.get(\"size\"), prop(\"panels\"), id);\n      const dragging2 = context.get(\"dragState\")?.resizeTriggerId === id;\n      const focused = dragging2 || context.get(\"keyboardState\")?.resizeTriggerId === id;\n      return normalize.element({\n        ...parts.resizeTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getResizeTriggerId(scope, id),\n        role: \"separator\",\n        \"data-id\": id,\n        \"data-ownedby\": getRootId(scope),\n        tabIndex: disabled ? void 0 : 0,\n        \"aria-valuenow\": aria.valueNow,\n        \"aria-valuemin\": aria.valueMin,\n        \"aria-valuemax\": aria.valueMax,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-orientation\": prop(\"orientation\"),\n        \"aria-controls\": `${getPanelId(scope, aria.beforeId)} ${getPanelId(scope, aria.afterId)}`,\n        \"data-focus\": dataAttr(focused),\n        \"data-disabled\": dataAttr(disabled),\n        style: {\n          touchAction: \"none\",\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\",\n          flex: \"0 0 auto\",\n          pointerEvents: dragging2 && !focused ? \"none\" : void 0,\n          cursor: horizontal ? \"col-resize\" : \"row-resize\",\n          [horizontal ? \"minHeight\" : \"minWidth\"]: \"0\"\n        },\n        onPointerDown(event) {\n          if (event.button !== 0) return;\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          const point = getEventPoint(event);\n          send({\n            type: \"POINTER_DOWN\",\n            id,\n            point\n          });\n          event.currentTarget.setPointerCapture(event.pointerId);\n          event.preventDefault();\n          event.stopPropagation();\n        },\n        onPointerUp(event) {\n          if (disabled) return;\n          if (event.currentTarget.hasPointerCapture(event.pointerId)) {\n            event.currentTarget.releasePointerCapture(event.pointerId);\n          }\n        },\n        onPointerOver() {\n          if (disabled) return;\n          send({\n            type: \"POINTER_OVER\",\n            id\n          });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({\n            type: \"POINTER_LEAVE\",\n            id\n          });\n        },\n        onBlur() {\n          if (disabled) return;\n          send({\n            type: \"BLUR\"\n          });\n        },\n        onFocus() {\n          if (disabled) return;\n          send({\n            type: \"FOCUS\",\n            id\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          const keyboardResizeBy = prop(\"keyboardResizeBy\");\n          let delta = 0;\n          if (event.shiftKey) {\n            delta = 10;\n          } else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n          } else {\n            delta = 1;\n          }\n          const keyMap = {\n            Enter() {\n              send({\n                type: \"ENTER\",\n                id\n              });\n            },\n            ArrowUp() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? 0 : -delta\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? 0 : delta\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? -delta : 0\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? delta : 0\n              });\n            },\n            Home() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: -100\n              });\n            },\n            End() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: 100\n              });\n            },\n            F6() {\n              send({\n                type: \"FOCUS.CYCLE\",\n                id,\n                shiftKey: event.shiftKey\n              });\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation: prop(\"orientation\")\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    }\n  };\n}\nfunction resizePanel({\n  panels,\n  index,\n  size\n}) {\n  const panel = panels[index];\n  ensure(panel, () => `Panel data not found for index ${index}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panel;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// src/utils/resize-by-delta.ts\nfunction resizeByDelta(props2) {\n  let {\n    delta,\n    initialSize,\n    panels,\n    pivotIndices,\n    prevSize,\n    trigger\n  } = props2;\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialSize;\n  }\n  const nextSize = [...initialSize];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  ensure(firstPivotIndex, () => \"Invalid first pivot index\");\n  ensure(secondPivotIndex, () => \"Invalid second pivot index\");\n  let deltaApplied = 0;\n  {\n    if (trigger === \"keyboard\") {\n      {\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `Panel data not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, collapsedSize)) {\n            const localDelta = minSize - prevSize2;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n      {\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `No panel data found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, minSize)) {\n            const localDelta = prevSize2 - collapsedSize;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n    }\n  }\n  {\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n    while (true) {\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panels,\n        index,\n        size: 100\n      });\n      const delta2 = maxSafeSize - prevSize2;\n      maxAvailableDelta += delta2;\n      index += increment;\n      if (index < 0 || index >= panels.length) {\n        break;\n      }\n    }\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n  }\n  {\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panels.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const unsafeSize = prevSize2 - deltaRemaining;\n      const safeSize = resizePanel({\n        panels,\n        index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize2, safeSize)) {\n        deltaApplied += prevSize2 - safeSize;\n        nextSize[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  if (fuzzySizeEqual(prevSize, nextSize)) {\n    return prevSize;\n  }\n  {\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize2 = initialSize[pivotIndex];\n    ensure(prevSize2, () => `Previous size not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize2 + deltaApplied;\n    const safeSize = resizePanel({\n      panels,\n      index: pivotIndex,\n      size: unsafeSize\n    });\n    nextSize[pivotIndex] = safeSize;\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex2;\n      while (index >= 0 && index < panels.length) {\n        const prevSize3 = nextSize[index];\n        ensure(prevSize3, () => `Previous size not found for panel index ${index}`);\n        const unsafeSize2 = prevSize3 + deltaRemaining;\n        const safeSize2 = resizePanel({\n          panels,\n          index,\n          size: unsafeSize2\n        });\n        if (!fuzzyNumbersEqual(prevSize3, safeSize2)) {\n          deltaRemaining -= safeSize2 - prevSize3;\n          nextSize[index] = safeSize2;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  const totalSize = nextSize.reduce((total, size) => size + total, 0);\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    return prevSize;\n  }\n  return nextSize;\n}\nfunction validateSizes({\n  size: prevSize,\n  panels\n}) {\n  const nextSize = [...prevSize];\n  const nextSizeTotalSize = nextSize.reduce((accumulated, current) => accumulated + current, 0);\n  if (nextSize.length !== panels.length) {\n    throw Error(`Invalid ${panels.length} panel size: ${nextSize.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextSizeTotalSize, 100) && nextSize.length > 0) {\n    for (let index = 0; index < panels.length; index++) {\n      const unsafeSize = nextSize[index];\n      ensure(unsafeSize, () => `No size data found for index ${index}`);\n      const safeSize = 100 / nextSizeTotalSize * unsafeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n  for (let index = 0; index < panels.length; index++) {\n    const unsafeSize = nextSize[index];\n    ensure(unsafeSize, () => `No size data found for index ${index}`);\n    const safeSize = resizePanel({\n      panels,\n      index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panels.length; index++) {\n      const prevSize2 = nextSize[index];\n      ensure(prevSize2, () => `No size data found for index ${index}`);\n      const unsafeSize = prevSize2 + remainingSize;\n      const safeSize = resizePanel({\n        panels,\n        index,\n        size: unsafeSize\n      });\n      if (prevSize2 !== safeSize) {\n        remainingSize -= safeSize - prevSize2;\n        nextSize[index] = safeSize;\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextSize;\n}\n\n// src/splitter.machine.ts\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    ensureProps(props2, [\"panels\"]);\n    return {\n      orientation: \"horizontal\",\n      defaultSize: [],\n      dir: \"ltr\",\n      ...props2,\n      panels: sortPanels(props2.panels)\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context({\n    prop,\n    bindable,\n    getContext,\n    getRefs\n  }) {\n    return {\n      size: bindable(() => ({\n        value: prop(\"size\"),\n        defaultValue: prop(\"defaultSize\"),\n        isEqual(a, b) {\n          return b != null && fuzzySizeEqual(a, b);\n        },\n        onChange(value) {\n          const ctx = getContext();\n          const refs = getRefs();\n          const sizesBeforeCollapse = refs.get(\"panelSizeBeforeCollapse\");\n          const expandToSizes = Object.fromEntries(sizesBeforeCollapse.entries());\n          const resizeTriggerId = ctx.get(\"dragState\")?.resizeTriggerId ?? null;\n          const layout = getPanelLayout(prop(\"panels\"));\n          prop(\"onResize\")?.({\n            size: value,\n            layout,\n            resizeTriggerId,\n            expandToSizes\n          });\n        }\n      })),\n      dragState: bindable(() => ({\n        defaultValue: null\n      })),\n      keyboardState: bindable(() => ({\n        defaultValue: null\n      }))\n    };\n  },\n  watch({\n    track,\n    action,\n    prop\n  }) {\n    track([() => serializePanels(prop(\"panels\"))], () => {\n      action([\"syncSize\"]);\n    });\n  },\n  refs() {\n    return {\n      panelSizeBeforeCollapse: /* @__PURE__ */new Map(),\n      prevDelta: 0,\n      panelIdToLastNotifiedSizeMap: /* @__PURE__ */new Map()\n    };\n  },\n  computed: {\n    horizontal({\n      prop\n    }) {\n      return prop(\"orientation\") === \"horizontal\";\n    }\n  },\n  on: {\n    \"SIZE.SET\": {\n      actions: [\"setSize\"]\n    },\n    \"PANEL.COLLAPSE\": {\n      actions: [\"collapsePanel\"]\n    },\n    \"PANEL.EXPAND\": {\n      actions: [\"expandPanel\"]\n    },\n    \"PANEL.RESIZE\": {\n      actions: [\"resizePanel\"]\n    }\n  },\n  entry: [\"syncSize\"],\n  states: {\n    idle: {\n      entry: [\"clearDraggingState\", \"clearKeyboardState\"],\n      on: {\n        POINTER_OVER: {\n          target: \"hover:temp\",\n          actions: [\"setKeyboardState\"]\n        },\n        FOCUS: {\n          target: \"focused\",\n          actions: [\"setKeyboardState\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        }\n      }\n    },\n    \"hover:temp\": {\n      effects: [\"waitForHoverDelay\"],\n      on: {\n        HOVER_DELAY: {\n          target: \"hover\"\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    hover: {\n      tags: [\"focus\"],\n      on: {\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    focused: {\n      tags: [\"focus\"],\n      on: {\n        BLUR: {\n          target: \"idle\"\n        },\n        ENTER: {\n          actions: [\"collapseOrExpandPanel\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        KEYBOARD_MOVE: {\n          actions: [\"invokeOnResizeStart\", \"setKeyboardValue\", \"invokeOnResizeEnd\"]\n        },\n        \"FOCUS.CYCLE\": {\n          actions: [\"focusNextResizeTrigger\"]\n        }\n      }\n    },\n    dragging: {\n      tags: [\"focus\"],\n      effects: [\"trackPointerMove\"],\n      entry: [\"invokeOnResizeStart\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"setPointerValue\", \"setGlobalCursor\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\"invokeOnResizeEnd\", \"clearGlobalCursor\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      waitForHoverDelay: ({\n        send\n      }) => {\n        return setRafTimeout(() => {\n          send({\n            type: \"HOVER_DELAY\"\n          });\n        }, 250);\n      },\n      trackPointerMove: ({\n        scope,\n        send\n      }) => {\n        const doc = scope.getDoc();\n        return trackPointerMove(doc, {\n          onPointerMove(info) {\n            send({\n              type: \"POINTER_MOVE\",\n              point: info.point\n            });\n          },\n          onPointerUp() {\n            send({\n              type: \"POINTER_UP\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      setSize(params) {\n        const {\n          context,\n          event,\n          prop\n        } = params;\n        const unsafeSize = event.size;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const safeSize = validateSizes({\n          size: unsafeSize,\n          panels\n        });\n        if (!isEqual(prevSize, safeSize)) {\n          setSize(params, safeSize);\n        }\n      },\n      syncSize({\n        context,\n        prop\n      }) {\n        const panels = prop(\"panels\");\n        let prevSize = context.get(\"size\");\n        let unsafeSize = null;\n        if (prevSize.length === 0) {\n          unsafeSize = getUnsafeDefaultSize({\n            panels,\n            size: context.initial(\"size\")\n          });\n        }\n        const nextSize = validateSizes({\n          size: unsafeSize ?? prevSize,\n          panels\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          context.set(\"size\", nextSize);\n        }\n      },\n      setDraggingState({\n        context,\n        event,\n        prop,\n        scope\n      }) {\n        const orientation = prop(\"orientation\");\n        const size = context.get(\"size\");\n        const resizeTriggerId = event.id;\n        const panelGroupEl = getRootEl(scope);\n        if (!panelGroupEl) return;\n        const handleElement = getResizeTriggerEl(scope, resizeTriggerId);\n        ensure(handleElement, () => `Drag handle element not found for id \"${resizeTriggerId}\"`);\n        const initialCursorPosition = orientation === \"horizontal\" ? event.point.x : event.point.y;\n        context.set(\"dragState\", {\n          resizeTriggerId: event.id,\n          resizeTriggerRect: handleElement.getBoundingClientRect(),\n          initialCursorPosition,\n          initialSize: size\n        });\n      },\n      clearDraggingState({\n        context\n      }) {\n        context.set(\"dragState\", null);\n      },\n      setKeyboardState({\n        context,\n        event\n      }) {\n        context.set(\"keyboardState\", {\n          resizeTriggerId: event.id\n        });\n      },\n      clearKeyboardState({\n        context\n      }) {\n        context.set(\"keyboardState\", null);\n      },\n      collapsePanel(params) {\n        const {\n          context,\n          prop,\n          event,\n          refs\n        } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = panels.find(panel2 => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const {\n            collapsedSize = 0,\n            panelSize,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n          if (!fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            refs.get(\"panelSizeBeforeCollapse\").set(panel.id, panelSize);\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      expandPanel(params) {\n        const {\n          context,\n          prop,\n          event,\n          refs\n        } = params;\n        const panels = prop(\"panels\");\n        const prevSize = context.get(\"size\");\n        const panel = panels.find(panel2 => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const {\n            collapsedSize = 0,\n            panelSize = 0,\n            minSize: minSizeFromProps = 0,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          const minSize = event.minSize ?? minSizeFromProps;\n          if (fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            const prevPanelSize = refs.get(\"panelSizeBeforeCollapse\").get(panel.id);\n            const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      resizePanel(params) {\n        const {\n          context,\n          prop,\n          event\n        } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = getPanelById(panels, event.id);\n        const unsafePanelSize = event.size;\n        const {\n          panelSize,\n          pivotIndices\n        } = panelDataHelper(panels, panel, prevSize);\n        ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n        const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"imperative-api\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setPointerValue(params) {\n        const {\n          context,\n          event,\n          prop,\n          scope\n        } = params;\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const {\n          resizeTriggerId,\n          initialSize,\n          initialCursorPosition\n        } = dragState;\n        const panels = prop(\"panels\");\n        const panelGroupElement = getRootEl(scope);\n        ensure(panelGroupElement, () => `Panel group element not found`);\n        const pivotIndices = resizeTriggerId.split(\":\").map(id => panels.findIndex(panel => panel.id === id));\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const cursorPosition = horizontal ? event.point.x : event.point.y;\n        const groupRect = panelGroupElement.getBoundingClientRect();\n        const groupSizeInPixels = horizontal ? groupRect.width : groupRect.height;\n        const offsetPixels = cursorPosition - initialCursorPosition;\n        const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta: offsetPercentage,\n          initialSize: initialSize ?? prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"mouse-or-touch\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setKeyboardValue(params) {\n        const {\n          context,\n          event,\n          prop\n        } = params;\n        const panelDataArray = prop(\"panels\");\n        const resizeTriggerId = event.id;\n        const delta = event.delta;\n        const pivotIndices = resizeTriggerId.split(\":\").map(id => panelDataArray.findIndex(panelData => panelData.id === id));\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels: panelDataArray,\n          pivotIndices,\n          prevSize,\n          trigger: \"keyboard\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      invokeOnResizeEnd({\n        context,\n        prop\n      }) {\n        queueMicrotask(() => {\n          const dragState = context.get(\"dragState\");\n          prop(\"onResizeEnd\")?.({\n            size: context.get(\"size\"),\n            resizeTriggerId: dragState?.resizeTriggerId ?? null\n          });\n        });\n      },\n      invokeOnResizeStart({\n        prop\n      }) {\n        queueMicrotask(() => {\n          prop(\"onResizeStart\")?.();\n        });\n      },\n      collapseOrExpandPanel(params) {\n        const {\n          context,\n          prop\n        } = params;\n        const panelDataArray = prop(\"panels\");\n        const sizes = context.get(\"size\");\n        const resizeTriggerId = context.get(\"keyboardState\")?.resizeTriggerId;\n        const [idBefore, idAfter] = resizeTriggerId?.split(\":\") ?? [];\n        const index = panelDataArray.findIndex(panelData2 => panelData2.id === idBefore);\n        if (index === -1) return;\n        const panelData = panelDataArray[index];\n        ensure(panelData, () => `No panel data found for index ${index}`);\n        const size = sizes[index];\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelData;\n        if (size != null && collapsible) {\n          const pivotIndices = [idBefore, idAfter].map(id => panelDataArray.findIndex(panelData2 => panelData2.id === id));\n          const nextSize = resizeByDelta({\n            delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n            initialSize: context.initial(\"size\"),\n            panels: panelDataArray,\n            pivotIndices,\n            prevSize: sizes,\n            trigger: \"keyboard\"\n          });\n          if (!isEqual(sizes, nextSize)) {\n            setSize(params, nextSize);\n          }\n        }\n      },\n      setGlobalCursor({\n        context,\n        scope,\n        prop\n      }) {\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const panels = prop(\"panels\");\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const [idBefore] = dragState.resizeTriggerId.split(\":\");\n        const indexBefore = panels.findIndex(panel2 => panel2.id === idBefore);\n        const panel = panels[indexBefore];\n        const size = context.get(\"size\");\n        const aria = getAriaValue(size, panels, dragState.resizeTriggerId);\n        const isAtMin = fuzzyNumbersEqual(aria.valueNow, aria.valueMin) || fuzzyNumbersEqual(aria.valueNow, panel.collapsedSize);\n        const isAtMax = fuzzyNumbersEqual(aria.valueNow, aria.valueMax);\n        const cursorState = {\n          isAtMin,\n          isAtMax\n        };\n        setupGlobalCursor(scope, cursorState, horizontal, prop(\"nonce\"));\n      },\n      clearGlobalCursor({\n        scope\n      }) {\n        removeGlobalCursor(scope);\n      },\n      focusNextResizeTrigger({\n        event,\n        scope\n      }) {\n        const resizeTriggers = getResizeTriggerEls(scope);\n        const index = resizeTriggers.findIndex(el => el.dataset.id === event.id);\n        const handleEl = event.shiftKey ? prev(resizeTriggers, index) : next(resizeTriggers, index);\n        handleEl?.focus();\n      }\n    }\n  }\n});\nfunction setSize(params, sizes) {\n  const {\n    refs,\n    prop,\n    context\n  } = params;\n  const panelsArray = prop(\"panels\");\n  const onCollapse = prop(\"onCollapse\");\n  const onExpand = prop(\"onExpand\");\n  const panelIdToLastNotifiedSizeMap = refs.get(\"panelIdToLastNotifiedSizeMap\");\n  context.set(\"size\", sizes);\n  sizes.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    ensure(panelData, () => `Panel data not found for index ${index}`);\n    const {\n      collapsedSize = 0,\n      collapsible,\n      id: panelId\n    } = panelData;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap.get(panelId);\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap.set(panelId, size);\n      if (collapsible && (onCollapse || onExpand)) {\n        if ((lastNotifiedSize == null || fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual(size, collapsedSize)) {\n          onExpand?.({\n            panelId,\n            size\n          });\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual(size, collapsedSize)) {\n          onCollapse?.({\n            panelId,\n            size\n          });\n        }\n      }\n    }\n  });\n}\nvar props = createProps()([\"dir\", \"getRootNode\", \"id\", \"ids\", \"onResize\", \"onResizeStart\", \"onResizeEnd\", \"onCollapse\", \"onExpand\", \"orientation\", \"size\", \"defaultSize\", \"panels\", \"keyboardResizeBy\", \"nonce\"]);\nvar splitProps = createSplitProps(props);\nvar panelProps = createProps()([\"id\"]);\nvar splitPanelProps = createSplitProps(panelProps);\nvar resizeTriggerProps = createProps()([\"disabled\", \"id\"]);\nvar splitResizeTriggerProps = createSplitProps(resizeTriggerProps);\nexport { anatomy, connect, getPanelLayout as layout, machine, panelProps, props, resizeTriggerProps, splitPanelProps, splitProps, splitResizeTriggerProps };","map":{"version":3,"names":["createAnatomy","trackPointerMove","queryAll","dataAttr","getEventKey","getEventPoint","prev","next","ensure","isEqual","setRafTimeout","ensureProps","createSplitProps","createMachine","createProps","anatomy","parts","build","getRootId","ctx","ids","root","id","getResizeTriggerId","resizeTrigger","getPanelId","panel","getGlobalCursorId","getRootEl","getById","getResizeTriggerEl","getCursor","state","x","cursor","isAtMin","isAtMax","getResizeTriggerEls","CSS","escape","setupGlobalCursor","nonce","styleEl","textContent","style","getDoc","createElement","head","appendChild","removeGlobalCursor","remove","calculateAriaValues","size","panels","pivotIndices","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","forEach","index","maxSize","minSize","valueMax","Math","min","valueMin","max","valueNow","getAriaValue","handleId","beforeId","afterId","split","beforeIndex","findIndex","afterIndex","round","PRECISION","fuzzyCompareNumbers","actual","expected","fractionDigits","toFixed","fuzzyNumbersEqual","fuzzySizeEqual","length","actualSize","expectedSize","getPanelById","find","panel2","findPanelDataIndex","prevPanel","findPanelIndex","panelDataHelper","sizes","panelSize","sortPanels","sort","panelA","panelB","orderA","order","orderB","getPanelLayout","map","join","serializePanels","keys","sortedKeys","serialized","key","JSON","stringify","getPanelFlexBoxStyle","defaultSize","dragState","panelIndex","precision","flexGrow","toPrecision","flexBasis","flexShrink","overflow","pointerEvents","getUnsafeDefaultSize","finalSizes","Array","numPanelsWithSizes","remainingSize","numRemainingPanels","connect","service","normalize","send","prop","computed","context","scope","horizontal","dragging","matches","getPanelStyle","initial","get","getItems","flatMap","arr","nextPanel","type","getSizes","setSizes","resetSizes","collapsePanel","expandPanel","resizePanel","unsafePanelSize","getPanelSize","panelData","isPanelCollapsed","collapsedSize","collapsible","isPanelExpanded","getLayout","getRootProps","element","attrs","dir","display","flexDirection","height","width","getPanelProps","props2","getResizeTriggerProps","disabled","aria","dragging2","resizeTriggerId","focused","role","tabIndex","touchAction","userSelect","WebkitUserSelect","flex","onPointerDown","event","button","preventDefault","point","currentTarget","setPointerCapture","pointerId","stopPropagation","onPointerUp","hasPointerCapture","releasePointerCapture","onPointerOver","onPointerLeave","onBlur","onFocus","onKeyDown","defaultPrevented","keyboardResizeBy","delta","shiftKey","keyMap","Enter","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Home","End","F6","orientation","exec","halfwayPoint","parseFloat","resizeByDelta","initialSize","prevSize","trigger","nextSize","firstPivotIndex","secondPivotIndex","deltaApplied","prevSize2","localDelta","abs","increment","maxAvailableDelta","maxSafeSize","delta2","minAbsDelta","pivotIndex","deltaRemaining","unsafeSize","safeSize","localeCompare","numeric","pivotIndex2","prevSize3","unsafeSize2","safeSize2","totalSize","reduce","total","validateSizes","nextSizeTotalSize","accumulated","current","Error","machine","props","initialState","bindable","getContext","getRefs","value","defaultValue","a","b","onChange","refs","sizesBeforeCollapse","expandToSizes","Object","fromEntries","entries","layout","keyboardState","watch","track","action","panelSizeBeforeCollapse","Map","prevDelta","panelIdToLastNotifiedSizeMap","on","actions","entry","states","idle","POINTER_OVER","target","FOCUS","POINTER_DOWN","effects","HOVER_DELAY","POINTER_LEAVE","hover","tags","BLUR","ENTER","KEYBOARD_MOVE","POINTER_MOVE","POINTER_UP","implementations","waitForHoverDelay","doc","onPointerMove","info","setSize","params","syncSize","set","setDraggingState","panelGroupEl","handleElement","initialCursorPosition","y","resizeTriggerRect","getBoundingClientRect","clearDraggingState","setKeyboardState","clearKeyboardState","isLastPanel","minSizeFromProps","prevPanelSize","baseSize","setPointerValue","panelGroupElement","cursorPosition","groupRect","groupSizeInPixels","offsetPixels","offsetPercentage","setKeyboardValue","panelDataArray","invokeOnResizeEnd","queueMicrotask","invokeOnResizeStart","collapseOrExpandPanel","idBefore","idAfter","panelData2","setGlobalCursor","indexBefore","cursorState","clearGlobalCursor","focusNextResizeTrigger","resizeTriggers","el","dataset","handleEl","focus","panelsArray","onCollapse","onExpand","panelId","lastNotifiedSize","splitProps","panelProps","splitPanelProps","resizeTriggerProps","splitResizeTriggerProps"],"sources":["C:/Users/tuanl/weekly-todo-frontend/node_modules/@zag-js/splitter/dist/index.mjs"],"sourcesContent":["import { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, queryAll, dataAttr, getEventKey, getEventPoint } from '@zag-js/dom-query';\nimport { prev, next, ensure, isEqual, setRafTimeout, ensureProps, createSplitProps } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/splitter.anatomy.ts\nvar anatomy = createAnatomy(\"splitter\").parts(\"root\", \"panel\", \"resizeTrigger\");\nvar parts = anatomy.build();\nvar getRootId = (ctx) => ctx.ids?.root ?? `splitter:${ctx.id}`;\nvar getResizeTriggerId = (ctx, id) => ctx.ids?.resizeTrigger?.(id) ?? `splitter:${ctx.id}:splitter:${id}`;\nvar getPanelId = (ctx, id) => ctx.ids?.panel?.(id) ?? `splitter:${ctx.id}:panel:${id}`;\nvar getGlobalCursorId = (ctx) => `splitter:${ctx.id}:global-cursor`;\nvar getRootEl = (ctx) => ctx.getById(getRootId(ctx));\nvar getResizeTriggerEl = (ctx, id) => ctx.getById(getResizeTriggerId(ctx, id));\nvar getCursor = (state, x) => {\n  let cursor = x ? \"col-resize\" : \"row-resize\";\n  if (state.isAtMin) cursor = x ? \"e-resize\" : \"s-resize\";\n  if (state.isAtMax) cursor = x ? \"w-resize\" : \"n-resize\";\n  return cursor;\n};\nvar getResizeTriggerEls = (ctx) => {\n  return queryAll(getRootEl(ctx), `[role=separator][data-ownedby='${CSS.escape(getRootId(ctx))}']`);\n};\nvar setupGlobalCursor = (ctx, state, x, nonce) => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  const textContent = `* { cursor: ${getCursor(state, x)} !important; }`;\n  if (styleEl) {\n    styleEl.textContent = textContent;\n  } else {\n    const style = ctx.getDoc().createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    style.id = getGlobalCursorId(ctx);\n    style.textContent = textContent;\n    ctx.getDoc().head.appendChild(style);\n  }\n};\nvar removeGlobalCursor = (ctx) => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  styleEl?.remove();\n};\nfunction calculateAriaValues({\n  size,\n  panels,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  ensure(firstIndex, () => \"No pivot index found\");\n  panels.forEach((panel, index) => {\n    const { maxSize = 100, minSize = 0 } = panel;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = size[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\nfunction getAriaValue(size, panels, handleId) {\n  const [beforeId, afterId] = handleId.split(\":\");\n  const beforeIndex = panels.findIndex((panel) => panel.id === beforeId);\n  const afterIndex = panels.findIndex((panel) => panel.id === afterId);\n  const { valueMax, valueMin, valueNow } = calculateAriaValues({\n    size,\n    panels,\n    pivotIndices: [beforeIndex, afterIndex]\n  });\n  return {\n    beforeId,\n    afterId,\n    valueMax: Math.round(valueMax),\n    valueMin: Math.round(valueMin),\n    valueNow: valueNow != null ? Math.round(valueNow) : void 0\n  };\n}\n\n// src/utils/fuzzy.ts\nvar PRECISION = 10;\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits = PRECISION) {\n  if (actual == null || expected == null) return false;\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzySizeEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getPanelById(panels, id) {\n  const panel = panels.find((panel2) => panel2.id === id);\n  ensure(panel, () => `Panel data not found for id \"${id}\"`);\n  return panel;\n}\nfunction findPanelDataIndex(panels, panel) {\n  return panels.findIndex((prevPanel) => prevPanel === panel || prevPanel.id === panel.id);\n}\nfunction findPanelIndex(panels, id) {\n  return panels.findIndex((panel) => panel.id === id);\n}\nfunction panelDataHelper(panels, panel, sizes) {\n  const index = findPanelIndex(panels, panel.id);\n  const pivotIndices = index === panels.length - 1 ? [index - 1, index] : [index, index + 1];\n  const panelSize = sizes[index];\n  return { ...panel, panelSize, pivotIndices };\n}\nfunction sortPanels(panels) {\n  return panels.sort((panelA, panelB) => {\n    const orderA = panelA.order;\n    const orderB = panelB.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction getPanelLayout(panels) {\n  return panels.map((panel) => panel.id).sort().join(\":\");\n}\nfunction serializePanels(panels) {\n  const keys = panels.map((panel) => panel.id);\n  const sortedKeys = keys.sort();\n  const serialized = sortedKeys.map((key) => {\n    const panel = panels.find((panel2) => panel2.id === key);\n    return JSON.stringify(panel);\n  });\n  return serialized.join(\",\");\n}\nfunction getPanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  sizes,\n  panels,\n  panelIndex,\n  precision = 3\n}) {\n  const size = sizes[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panels.length === 1) {\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : void 0\n  };\n}\nfunction getUnsafeDefaultSize({ panels, size: sizes }) {\n  const finalSizes = Array(panels.length);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      finalSizes[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panels.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    finalSizes[index] = size;\n    remainingSize -= size;\n  }\n  return finalSizes;\n}\n\n// src/splitter.connect.ts\nfunction connect(service, normalize) {\n  const { state, send, prop, computed, context, scope } = service;\n  const horizontal = computed(\"horizontal\");\n  const dragging = state.matches(\"dragging\");\n  const getPanelStyle = (id) => {\n    const panels = prop(\"panels\");\n    const panelIndex = panels.findIndex((panel) => panel.id === id);\n    const defaultSize = context.initial(\"size\")[panelIndex];\n    const dragState = context.get(\"dragState\");\n    return getPanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      sizes: context.get(\"size\"),\n      panels,\n      panelIndex\n    });\n  };\n  return {\n    dragging,\n    getItems() {\n      return prop(\"panels\").flatMap((panel, index, arr) => {\n        const nextPanel = arr[index + 1];\n        if (panel && nextPanel) {\n          return [\n            { type: \"panel\", id: panel.id },\n            { type: \"handle\", id: `${panel.id}:${nextPanel.id}` }\n          ];\n        }\n        return [{ type: \"panel\", id: panel.id }];\n      });\n    },\n    getSizes() {\n      return context.get(\"size\");\n    },\n    setSizes(size) {\n      send({ type: \"SIZE.SET\", size });\n    },\n    resetSizes() {\n      send({ type: \"SIZE.SET\", size: context.initial(\"size\") });\n    },\n    collapsePanel(id) {\n      send({ type: \"PANEL.COLLAPSE\", id });\n    },\n    expandPanel(id, minSize) {\n      send({ type: \"PANEL.EXPAND\", id, minSize });\n    },\n    resizePanel(id, unsafePanelSize) {\n      send({ type: \"PANEL.RESIZE\", id, size: unsafePanelSize });\n    },\n    getPanelSize(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const { panelSize } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return panelSize;\n    },\n    isPanelCollapsed(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return collapsible === true && fuzzyNumbersEqual(panelSize, collapsedSize);\n    },\n    isPanelExpanded(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n    },\n    getLayout() {\n      return getPanelLayout(prop(\"panels\"));\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-orientation\": prop(\"orientation\"),\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        style: {\n          display: \"flex\",\n          flexDirection: horizontal ? \"row\" : \"column\",\n          height: \"100%\",\n          width: \"100%\",\n          overflow: \"hidden\"\n        }\n      });\n    },\n    getPanelProps(props2) {\n      const { id } = props2;\n      return normalize.element({\n        ...parts.panel.attrs,\n        \"data-orientation\": prop(\"orientation\"),\n        dir: prop(\"dir\"),\n        \"data-id\": id,\n        \"data-index\": findPanelIndex(prop(\"panels\"), id),\n        id: getPanelId(scope, id),\n        \"data-ownedby\": getRootId(scope),\n        style: getPanelStyle(id)\n      });\n    },\n    getResizeTriggerProps(props2) {\n      const { id, disabled } = props2;\n      const aria = getAriaValue(context.get(\"size\"), prop(\"panels\"), id);\n      const dragging2 = context.get(\"dragState\")?.resizeTriggerId === id;\n      const focused = dragging2 || context.get(\"keyboardState\")?.resizeTriggerId === id;\n      return normalize.element({\n        ...parts.resizeTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getResizeTriggerId(scope, id),\n        role: \"separator\",\n        \"data-id\": id,\n        \"data-ownedby\": getRootId(scope),\n        tabIndex: disabled ? void 0 : 0,\n        \"aria-valuenow\": aria.valueNow,\n        \"aria-valuemin\": aria.valueMin,\n        \"aria-valuemax\": aria.valueMax,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-orientation\": prop(\"orientation\"),\n        \"aria-controls\": `${getPanelId(scope, aria.beforeId)} ${getPanelId(scope, aria.afterId)}`,\n        \"data-focus\": dataAttr(focused),\n        \"data-disabled\": dataAttr(disabled),\n        style: {\n          touchAction: \"none\",\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\",\n          flex: \"0 0 auto\",\n          pointerEvents: dragging2 && !focused ? \"none\" : void 0,\n          cursor: horizontal ? \"col-resize\" : \"row-resize\",\n          [horizontal ? \"minHeight\" : \"minWidth\"]: \"0\"\n        },\n        onPointerDown(event) {\n          if (event.button !== 0) return;\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          const point = getEventPoint(event);\n          send({ type: \"POINTER_DOWN\", id, point });\n          event.currentTarget.setPointerCapture(event.pointerId);\n          event.preventDefault();\n          event.stopPropagation();\n        },\n        onPointerUp(event) {\n          if (disabled) return;\n          if (event.currentTarget.hasPointerCapture(event.pointerId)) {\n            event.currentTarget.releasePointerCapture(event.pointerId);\n          }\n        },\n        onPointerOver() {\n          if (disabled) return;\n          send({ type: \"POINTER_OVER\", id });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({ type: \"POINTER_LEAVE\", id });\n        },\n        onBlur() {\n          if (disabled) return;\n          send({ type: \"BLUR\" });\n        },\n        onFocus() {\n          if (disabled) return;\n          send({ type: \"FOCUS\", id });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          const keyboardResizeBy = prop(\"keyboardResizeBy\");\n          let delta = 0;\n          if (event.shiftKey) {\n            delta = 10;\n          } else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n          } else {\n            delta = 1;\n          }\n          const keyMap = {\n            Enter() {\n              send({ type: \"ENTER\", id });\n            },\n            ArrowUp() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? 0 : -delta });\n            },\n            ArrowDown() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? 0 : delta });\n            },\n            ArrowLeft() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? -delta : 0 });\n            },\n            ArrowRight() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? delta : 0 });\n            },\n            Home() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: -100 });\n            },\n            End() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: 100 });\n            },\n            F6() {\n              send({ type: \"FOCUS.CYCLE\", id, shiftKey: event.shiftKey });\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation: prop(\"orientation\")\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    }\n  };\n}\nfunction resizePanel({ panels, index, size }) {\n  const panel = panels[index];\n  ensure(panel, () => `Panel data not found for index ${index}`);\n  let { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = panel;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// src/utils/resize-by-delta.ts\nfunction resizeByDelta(props2) {\n  let { delta, initialSize, panels, pivotIndices, prevSize, trigger } = props2;\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialSize;\n  }\n  const nextSize = [...initialSize];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  ensure(firstPivotIndex, () => \"Invalid first pivot index\");\n  ensure(secondPivotIndex, () => \"Invalid second pivot index\");\n  let deltaApplied = 0;\n  {\n    if (trigger === \"keyboard\") {\n      {\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `Panel data not found for index ${index}`);\n        const { collapsedSize = 0, collapsible, minSize = 0 } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, collapsedSize)) {\n            const localDelta = minSize - prevSize2;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n      {\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `No panel data found for index ${index}`);\n        const { collapsedSize = 0, collapsible, minSize = 0 } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, minSize)) {\n            const localDelta = prevSize2 - collapsedSize;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n    }\n  }\n  {\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n    while (true) {\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panels,\n        index,\n        size: 100\n      });\n      const delta2 = maxSafeSize - prevSize2;\n      maxAvailableDelta += delta2;\n      index += increment;\n      if (index < 0 || index >= panels.length) {\n        break;\n      }\n    }\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n  }\n  {\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panels.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const unsafeSize = prevSize2 - deltaRemaining;\n      const safeSize = resizePanel({ panels, index, size: unsafeSize });\n      if (!fuzzyNumbersEqual(prevSize2, safeSize)) {\n        deltaApplied += prevSize2 - safeSize;\n        nextSize[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  if (fuzzySizeEqual(prevSize, nextSize)) {\n    return prevSize;\n  }\n  {\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize2 = initialSize[pivotIndex];\n    ensure(prevSize2, () => `Previous size not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize2 + deltaApplied;\n    const safeSize = resizePanel({ panels, index: pivotIndex, size: unsafeSize });\n    nextSize[pivotIndex] = safeSize;\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex2;\n      while (index >= 0 && index < panels.length) {\n        const prevSize3 = nextSize[index];\n        ensure(prevSize3, () => `Previous size not found for panel index ${index}`);\n        const unsafeSize2 = prevSize3 + deltaRemaining;\n        const safeSize2 = resizePanel({ panels, index, size: unsafeSize2 });\n        if (!fuzzyNumbersEqual(prevSize3, safeSize2)) {\n          deltaRemaining -= safeSize2 - prevSize3;\n          nextSize[index] = safeSize2;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  const totalSize = nextSize.reduce((total, size) => size + total, 0);\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    return prevSize;\n  }\n  return nextSize;\n}\nfunction validateSizes({ size: prevSize, panels }) {\n  const nextSize = [...prevSize];\n  const nextSizeTotalSize = nextSize.reduce((accumulated, current) => accumulated + current, 0);\n  if (nextSize.length !== panels.length) {\n    throw Error(`Invalid ${panels.length} panel size: ${nextSize.map((size) => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextSizeTotalSize, 100) && nextSize.length > 0) {\n    for (let index = 0; index < panels.length; index++) {\n      const unsafeSize = nextSize[index];\n      ensure(unsafeSize, () => `No size data found for index ${index}`);\n      const safeSize = 100 / nextSizeTotalSize * unsafeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n  for (let index = 0; index < panels.length; index++) {\n    const unsafeSize = nextSize[index];\n    ensure(unsafeSize, () => `No size data found for index ${index}`);\n    const safeSize = resizePanel({ panels, index, size: unsafeSize });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panels.length; index++) {\n      const prevSize2 = nextSize[index];\n      ensure(prevSize2, () => `No size data found for index ${index}`);\n      const unsafeSize = prevSize2 + remainingSize;\n      const safeSize = resizePanel({ panels, index, size: unsafeSize });\n      if (prevSize2 !== safeSize) {\n        remainingSize -= safeSize - prevSize2;\n        nextSize[index] = safeSize;\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextSize;\n}\n\n// src/splitter.machine.ts\nvar machine = createMachine({\n  props({ props: props2 }) {\n    ensureProps(props2, [\"panels\"]);\n    return {\n      orientation: \"horizontal\",\n      defaultSize: [],\n      dir: \"ltr\",\n      ...props2,\n      panels: sortPanels(props2.panels)\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context({ prop, bindable, getContext, getRefs }) {\n    return {\n      size: bindable(() => ({\n        value: prop(\"size\"),\n        defaultValue: prop(\"defaultSize\"),\n        isEqual(a, b) {\n          return b != null && fuzzySizeEqual(a, b);\n        },\n        onChange(value) {\n          const ctx = getContext();\n          const refs = getRefs();\n          const sizesBeforeCollapse = refs.get(\"panelSizeBeforeCollapse\");\n          const expandToSizes = Object.fromEntries(sizesBeforeCollapse.entries());\n          const resizeTriggerId = ctx.get(\"dragState\")?.resizeTriggerId ?? null;\n          const layout = getPanelLayout(prop(\"panels\"));\n          prop(\"onResize\")?.({\n            size: value,\n            layout,\n            resizeTriggerId,\n            expandToSizes\n          });\n        }\n      })),\n      dragState: bindable(() => ({\n        defaultValue: null\n      })),\n      keyboardState: bindable(() => ({\n        defaultValue: null\n      }))\n    };\n  },\n  watch({ track, action, prop }) {\n    track([() => serializePanels(prop(\"panels\"))], () => {\n      action([\"syncSize\"]);\n    });\n  },\n  refs() {\n    return {\n      panelSizeBeforeCollapse: /* @__PURE__ */ new Map(),\n      prevDelta: 0,\n      panelIdToLastNotifiedSizeMap: /* @__PURE__ */ new Map()\n    };\n  },\n  computed: {\n    horizontal({ prop }) {\n      return prop(\"orientation\") === \"horizontal\";\n    }\n  },\n  on: {\n    \"SIZE.SET\": {\n      actions: [\"setSize\"]\n    },\n    \"PANEL.COLLAPSE\": {\n      actions: [\"collapsePanel\"]\n    },\n    \"PANEL.EXPAND\": {\n      actions: [\"expandPanel\"]\n    },\n    \"PANEL.RESIZE\": {\n      actions: [\"resizePanel\"]\n    }\n  },\n  entry: [\"syncSize\"],\n  states: {\n    idle: {\n      entry: [\"clearDraggingState\", \"clearKeyboardState\"],\n      on: {\n        POINTER_OVER: {\n          target: \"hover:temp\",\n          actions: [\"setKeyboardState\"]\n        },\n        FOCUS: {\n          target: \"focused\",\n          actions: [\"setKeyboardState\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        }\n      }\n    },\n    \"hover:temp\": {\n      effects: [\"waitForHoverDelay\"],\n      on: {\n        HOVER_DELAY: {\n          target: \"hover\"\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    hover: {\n      tags: [\"focus\"],\n      on: {\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    focused: {\n      tags: [\"focus\"],\n      on: {\n        BLUR: {\n          target: \"idle\"\n        },\n        ENTER: {\n          actions: [\"collapseOrExpandPanel\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        KEYBOARD_MOVE: {\n          actions: [\"invokeOnResizeStart\", \"setKeyboardValue\", \"invokeOnResizeEnd\"]\n        },\n        \"FOCUS.CYCLE\": {\n          actions: [\"focusNextResizeTrigger\"]\n        }\n      }\n    },\n    dragging: {\n      tags: [\"focus\"],\n      effects: [\"trackPointerMove\"],\n      entry: [\"invokeOnResizeStart\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"setPointerValue\", \"setGlobalCursor\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\"invokeOnResizeEnd\", \"clearGlobalCursor\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      waitForHoverDelay: ({ send }) => {\n        return setRafTimeout(() => {\n          send({ type: \"HOVER_DELAY\" });\n        }, 250);\n      },\n      trackPointerMove: ({ scope, send }) => {\n        const doc = scope.getDoc();\n        return trackPointerMove(doc, {\n          onPointerMove(info) {\n            send({ type: \"POINTER_MOVE\", point: info.point });\n          },\n          onPointerUp() {\n            send({ type: \"POINTER_UP\" });\n          }\n        });\n      }\n    },\n    actions: {\n      setSize(params) {\n        const { context, event, prop } = params;\n        const unsafeSize = event.size;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const safeSize = validateSizes({\n          size: unsafeSize,\n          panels\n        });\n        if (!isEqual(prevSize, safeSize)) {\n          setSize(params, safeSize);\n        }\n      },\n      syncSize({ context, prop }) {\n        const panels = prop(\"panels\");\n        let prevSize = context.get(\"size\");\n        let unsafeSize = null;\n        if (prevSize.length === 0) {\n          unsafeSize = getUnsafeDefaultSize({\n            panels,\n            size: context.initial(\"size\")\n          });\n        }\n        const nextSize = validateSizes({\n          size: unsafeSize ?? prevSize,\n          panels\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          context.set(\"size\", nextSize);\n        }\n      },\n      setDraggingState({ context, event, prop, scope }) {\n        const orientation = prop(\"orientation\");\n        const size = context.get(\"size\");\n        const resizeTriggerId = event.id;\n        const panelGroupEl = getRootEl(scope);\n        if (!panelGroupEl) return;\n        const handleElement = getResizeTriggerEl(scope, resizeTriggerId);\n        ensure(handleElement, () => `Drag handle element not found for id \"${resizeTriggerId}\"`);\n        const initialCursorPosition = orientation === \"horizontal\" ? event.point.x : event.point.y;\n        context.set(\"dragState\", {\n          resizeTriggerId: event.id,\n          resizeTriggerRect: handleElement.getBoundingClientRect(),\n          initialCursorPosition,\n          initialSize: size\n        });\n      },\n      clearDraggingState({ context }) {\n        context.set(\"dragState\", null);\n      },\n      setKeyboardState({ context, event }) {\n        context.set(\"keyboardState\", {\n          resizeTriggerId: event.id\n        });\n      },\n      clearKeyboardState({ context }) {\n        context.set(\"keyboardState\", null);\n      },\n      collapsePanel(params) {\n        const { context, prop, event, refs } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = panels.find((panel2) => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const { collapsedSize = 0, panelSize, pivotIndices } = panelDataHelper(panels, panel, prevSize);\n          ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n          if (!fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            refs.get(\"panelSizeBeforeCollapse\").set(panel.id, panelSize);\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      expandPanel(params) {\n        const { context, prop, event, refs } = params;\n        const panels = prop(\"panels\");\n        const prevSize = context.get(\"size\");\n        const panel = panels.find((panel2) => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const {\n            collapsedSize = 0,\n            panelSize = 0,\n            minSize: minSizeFromProps = 0,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          const minSize = event.minSize ?? minSizeFromProps;\n          if (fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            const prevPanelSize = refs.get(\"panelSizeBeforeCollapse\").get(panel.id);\n            const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      resizePanel(params) {\n        const { context, prop, event } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = getPanelById(panels, event.id);\n        const unsafePanelSize = event.size;\n        const { panelSize, pivotIndices } = panelDataHelper(panels, panel, prevSize);\n        ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n        const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"imperative-api\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setPointerValue(params) {\n        const { context, event, prop, scope } = params;\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const { resizeTriggerId, initialSize, initialCursorPosition } = dragState;\n        const panels = prop(\"panels\");\n        const panelGroupElement = getRootEl(scope);\n        ensure(panelGroupElement, () => `Panel group element not found`);\n        const pivotIndices = resizeTriggerId.split(\":\").map((id) => panels.findIndex((panel) => panel.id === id));\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const cursorPosition = horizontal ? event.point.x : event.point.y;\n        const groupRect = panelGroupElement.getBoundingClientRect();\n        const groupSizeInPixels = horizontal ? groupRect.width : groupRect.height;\n        const offsetPixels = cursorPosition - initialCursorPosition;\n        const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta: offsetPercentage,\n          initialSize: initialSize ?? prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"mouse-or-touch\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setKeyboardValue(params) {\n        const { context, event, prop } = params;\n        const panelDataArray = prop(\"panels\");\n        const resizeTriggerId = event.id;\n        const delta = event.delta;\n        const pivotIndices = resizeTriggerId.split(\":\").map((id) => panelDataArray.findIndex((panelData) => panelData.id === id));\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels: panelDataArray,\n          pivotIndices,\n          prevSize,\n          trigger: \"keyboard\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      invokeOnResizeEnd({ context, prop }) {\n        queueMicrotask(() => {\n          const dragState = context.get(\"dragState\");\n          prop(\"onResizeEnd\")?.({\n            size: context.get(\"size\"),\n            resizeTriggerId: dragState?.resizeTriggerId ?? null\n          });\n        });\n      },\n      invokeOnResizeStart({ prop }) {\n        queueMicrotask(() => {\n          prop(\"onResizeStart\")?.();\n        });\n      },\n      collapseOrExpandPanel(params) {\n        const { context, prop } = params;\n        const panelDataArray = prop(\"panels\");\n        const sizes = context.get(\"size\");\n        const resizeTriggerId = context.get(\"keyboardState\")?.resizeTriggerId;\n        const [idBefore, idAfter] = resizeTriggerId?.split(\":\") ?? [];\n        const index = panelDataArray.findIndex((panelData2) => panelData2.id === idBefore);\n        if (index === -1) return;\n        const panelData = panelDataArray[index];\n        ensure(panelData, () => `No panel data found for index ${index}`);\n        const size = sizes[index];\n        const { collapsedSize = 0, collapsible, minSize = 0 } = panelData;\n        if (size != null && collapsible) {\n          const pivotIndices = [idBefore, idAfter].map(\n            (id) => panelDataArray.findIndex((panelData2) => panelData2.id === id)\n          );\n          const nextSize = resizeByDelta({\n            delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n            initialSize: context.initial(\"size\"),\n            panels: panelDataArray,\n            pivotIndices,\n            prevSize: sizes,\n            trigger: \"keyboard\"\n          });\n          if (!isEqual(sizes, nextSize)) {\n            setSize(params, nextSize);\n          }\n        }\n      },\n      setGlobalCursor({ context, scope, prop }) {\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const panels = prop(\"panels\");\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const [idBefore] = dragState.resizeTriggerId.split(\":\");\n        const indexBefore = panels.findIndex((panel2) => panel2.id === idBefore);\n        const panel = panels[indexBefore];\n        const size = context.get(\"size\");\n        const aria = getAriaValue(size, panels, dragState.resizeTriggerId);\n        const isAtMin = fuzzyNumbersEqual(aria.valueNow, aria.valueMin) || fuzzyNumbersEqual(aria.valueNow, panel.collapsedSize);\n        const isAtMax = fuzzyNumbersEqual(aria.valueNow, aria.valueMax);\n        const cursorState = { isAtMin, isAtMax };\n        setupGlobalCursor(scope, cursorState, horizontal, prop(\"nonce\"));\n      },\n      clearGlobalCursor({ scope }) {\n        removeGlobalCursor(scope);\n      },\n      focusNextResizeTrigger({ event, scope }) {\n        const resizeTriggers = getResizeTriggerEls(scope);\n        const index = resizeTriggers.findIndex((el) => el.dataset.id === event.id);\n        const handleEl = event.shiftKey ? prev(resizeTriggers, index) : next(resizeTriggers, index);\n        handleEl?.focus();\n      }\n    }\n  }\n});\nfunction setSize(params, sizes) {\n  const { refs, prop, context } = params;\n  const panelsArray = prop(\"panels\");\n  const onCollapse = prop(\"onCollapse\");\n  const onExpand = prop(\"onExpand\");\n  const panelIdToLastNotifiedSizeMap = refs.get(\"panelIdToLastNotifiedSizeMap\");\n  context.set(\"size\", sizes);\n  sizes.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    ensure(panelData, () => `Panel data not found for index ${index}`);\n    const { collapsedSize = 0, collapsible, id: panelId } = panelData;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap.get(panelId);\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap.set(panelId, size);\n      if (collapsible && (onCollapse || onExpand)) {\n        if ((lastNotifiedSize == null || fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual(size, collapsedSize)) {\n          onExpand?.({ panelId, size });\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual(size, collapsedSize)) {\n          onCollapse?.({ panelId, size });\n        }\n      }\n    }\n  });\n}\nvar props = createProps()([\n  \"dir\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"onResize\",\n  \"onResizeStart\",\n  \"onResizeEnd\",\n  \"onCollapse\",\n  \"onExpand\",\n  \"orientation\",\n  \"size\",\n  \"defaultSize\",\n  \"panels\",\n  \"keyboardResizeBy\",\n  \"nonce\"\n]);\nvar splitProps = createSplitProps(props);\nvar panelProps = createProps()([\"id\"]);\nvar splitPanelProps = createSplitProps(panelProps);\nvar resizeTriggerProps = createProps()([\"disabled\", \"id\"]);\nvar splitResizeTriggerProps = createSplitProps(resizeTriggerProps);\n\nexport { anatomy, connect, getPanelLayout as layout, machine, panelProps, props, resizeTriggerProps, splitPanelProps, splitProps, splitResizeTriggerProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}